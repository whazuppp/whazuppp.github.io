<!DOCTYPE html><html lang="zh-CN (简体中文)" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java复习Day3 | What the F</title><meta name="author" content="WZH"><meta name="copyright" content="WZH"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java复习Day3 学到的接口： implements Serializable, Cloneable, Comparable 常见API学习  lang包不用导包 Object类1.toString() 引用类型变量未重写则打印的是地址而非内容，需要重写toString方法 1.s1.toString()与s1始终等效 2.像集合这些已经帮你重写好了toString方法 2.equals()">
<meta property="og:type" content="article">
<meta property="og:title" content="Java复习Day3">
<meta property="og:url" content="http://example.com/2024/01/19/JavaSEReview3/index.html">
<meta property="og:site_name" content="What the F">
<meta property="og:description" content="Java复习Day3 学到的接口： implements Serializable, Cloneable, Comparable 常见API学习  lang包不用导包 Object类1.toString() 引用类型变量未重写则打印的是地址而非内容，需要重写toString方法 1.s1.toString()与s1始终等效 2.像集合这些已经帮你重写好了toString方法 2.equals()">
<meta property="og:locale">
<meta property="og:image" content="https://s21.ax1x.com/2024/12/21/pAO7nqH.png">
<meta property="article:published_time" content="2024-01-19T12:17:07.000Z">
<meta property="article:modified_time" content="2025-02-07T13:18:20.465Z">
<meta property="article:author" content="WZH">
<meta property="article:tag" content="JavaSE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s21.ax1x.com/2024/12/21/pAO7nqH.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/01/19/JavaSEReview3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java复习Day3',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/bat.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/joker.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://s21.ax1x.com/2024/12/21/pAO7nqH.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">What the F</span></a><a class="nav-page-title" href="/"><span class="site-name">Java复习Day3</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java复习Day3</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-01-19T12:17:07.000Z" title="Created 2024-01-19 20:17:07">2024-01-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-02-07T13:18:20.465Z" title="Updated 2025-02-07 21:18:20">2025-02-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaSE/">JavaSE</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-02-07 21:18:20&quot;}" hidden></div><h2 id="Java复习Day3"><a href="#Java复习Day3" class="headerlink" title=" Java复习Day3"></a><center><font face="楷体"   size=7   > Java复习Day3</font></center></h2><p> 学到的接口：<br> implements Serializable, Cloneable, Comparable<T></p>
<h3 id="常见API学习"><a href="#常见API学习" class="headerlink" title="常见API学习"></a>常见API学习</h3><p> <img src="https://s1.imagehub.cc/images/2025/02/06/ff8593d3547aed1f6dc53a1ca6c798a3.png" alt="Snipaste 2025 02 06 21 50 36"><br> lang包不用导包</p>
<h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><h5 id="1-toString"><a href="#1-toString" class="headerlink" title="1.toString()"></a>1.toString()</h5><p> 引用类型变量未重写则打印的是地址而非内容，需要重写toString方法<br> 1.s1.toString()与s1始终等效<br> 2.像集合这些已经帮你重写好了toString方法</p>
<h5 id="2-equals"><a href="#2-equals" class="headerlink" title="2.equals()"></a>2.equals()</h5><p>1.s1&#x3D;&#x3D;s2不管是否重写equals()，始终比较的是二者的地址<br>2.s1.equals(s2)比较地址，自己重写之后才比较内容（可自己制定比较哪些内容）<br>3.Objects .equals(s1,s2)相比上一条，此方法更加安全不会出现由于为null导致的异常(Objects的方法)<br>源码：public static boolean equals(Object a, Object b) {<br>                return (a &#x3D;&#x3D; b) || (a !&#x3D; null &amp;&amp; a.equals(b));<br>            }  </p>
<h5 id="3-clone"><a href="#3-clone" class="headerlink" title="3.clone()"></a>3.clone()</h5><p> 要克隆某个类，首先让该类实现Cloneable这一标记接口（空接口），然后重写其clone方法<br> 假设此类为User1</p>
<ol>
<li>直接生成的是浅克隆<br> @Override<br>protected Object clone() throws CloneNotSupportedException {<br>return super.clone();<br>}<br>  若本类成员变量存在引用类型比如说数组，浅克隆出的User2数组地址和它一样<br>  比如都是[D@1b6d3586</li>
<li>自己手写深克隆<br>@Override<br>protected Object clone() throws CloneNotSupportedException {<br>   User s2&#x3D;(User)super.clone();<br>   s2.scores&#x3D; s2.scores.clone();&#x2F;&#x2F;单独克隆对象里的引用对象<br>   return s2;<br>}<br>此时克隆对象地址变为[D@4554617c</li>
</ol>
<h4 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h4><h5 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h5><p> 为了实现万物皆对象，把基本类型的变量改为对象<br>char – Character<br>int –Integer<br>应用:eg.泛型只支持引用类型数据，不支持基本数据类型</p>
<ol>
<li>自动装箱与自动拆箱机制<br>Integer i1&#x3D;12;&#x2F;&#x2F;自动装箱（int-&gt;Integer）<br>int a3&#x3D;i1;&#x2F;&#x2F;自动拆箱（Integer-&gt;int）</li>
<li>Integer-&gt;String<br> Integer.toString(12);&#x2F;&#x2F;法一<br> i1.toString();&#x2F;&#x2F;法二<br> i1+” “&#x2F;&#x2F;法三,用String对象来接</li>
<li>String-&gt;Integer<br> Integer.parseInt(“29”)&#x2F;&#x2F;法一<br>Integer.valueOf(“29”);&#x2F;&#x2F;法二</li>
</ol>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>开始之前的注意:<br>1.StringBuilder线程不安全，StringBuffer线程安全<br>2.对于字符串频繁的修改和拼接，用StringBuilder而非String效率更高<br>3.如果操作字符串较小或者不需要操作以及定义字符串常量还是建议用String<br>4.StringBuilder重写了toString方法</p>
<h6 id="String-1"><a href="#String-1" class="headerlink" title="String"></a>String</h6><p><a target="_blank" rel="noopener" href="https://imgse.com/i/pEkrdfI"><img src="https://s21.ax1x.com/2025/01/19/pEkrdfI.png" alt="pEkrdfI.png"></a><br><a target="_blank" rel="noopener" href="https://imgse.com/i/pEkr0pt"><img src="https://s21.ax1x.com/2025/01/19/pEkr0pt.png" alt="pEkr0pt.png"></a><br>比如split(“,”)是以逗号为分隔符，把分开的一个个的对象存入字符串数组</p>
<h6 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h6><p>StringBuilder s&#x3D;new StringBuilder();<br>s.append(“666”).append(“7777”);&#x2F;&#x2F; 1.支持链式编程<br>s.reverse();&#x2F;&#x2F; 2.反转<br>s.length()&#x2F;&#x2F; 3.获取长度</p>
<h6 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h6><p>用法和StringBuilder差不多就不说了</p>
<h6 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h6><p>StringJoiner sJ&#x3D;new StringJoiner(“,”,”[“,”]”);&#x2F;&#x2F;间隔符，开头，结尾<br>        sJ.add(“7”);<br>        sJ.length();<br>        sJ.toString();&#x2F;&#x2F;StringJoiner-&gt;String</p>
<h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><p><a target="_blank" rel="noopener" href="https://imgse.com/i/pEkXYxx"><img src="https://s21.ax1x.com/2025/01/20/pEkXYxx.png" alt="pEkXYxx.png"></a></p>
<h4 id="System"><a href="#System" class="headerlink" title="System"></a>System</h4><p>System.exit(0);&#x2F;&#x2F;非0是异常退出,人为退出虚拟机不要使用<br>        long time1 &#x3D;System.currentTimeMillis();<br>        System.out.println(time1+”ms”);&#x2F;&#x2F;获取系统的时间，指的是从1970-1-1至今的毫秒总数<br>        …..&#x2F;&#x2F;代码<br>        long time2 &#x3D;System.currentTimeMillis();<br>        System.out.println(“程序执行时间为”+(time2-time1)+”ms”);&#x2F;&#x2F;得到执行代码段一共需要的时间</p>
<p>其他获取系统的时间（指的是从1970-1-1至今的毫秒总数）的方法<br>Date date&#x3D;new Date();&#x2F;&#x2F;构造器1<br>       long time&#x3D;date.getTime();   </p>
<h4 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h4><p>Runtime r&#x3D;Runtime.getRuntime();&#x2F;&#x2F;返回与当前Java程序关联的运行时对象<br>        r.exit(0);&#x2F;&#x2F;终止当前正在运行的虚拟机<br>        r.availableProcessors();&#x2F;&#x2F;获取虚拟机能够使用的虚拟器数<br>        r.totalMemory();&#x2F;&#x2F;Java虚拟机内存总量<br>        r.freeMemory();&#x2F;&#x2F;Java虚拟机可用内存<br>        r.exec(“E:\SMSBoomGUI_V1.3.0Beta (1)”);&#x2F;&#x2F;参数要为String格式，抛异常<br>进程Process<br>Process  p&#x3D; r.exec(“QQ”);&#x2F;&#x2F;前提是QQ配置了环境变量<br>        Thread.sleep(5000);&#x2F;&#x2F;睡眠5000ms，抛异常<br>        p.destroy();&#x2F;&#x2F;销毁，关闭程序        </p>
<h4 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h4><p>BigDecimal写法用于解决浮点数运算结果失真的情况，要求得到具体值<br>比如若遇到1.0&#x2F;3.0这种就需要更改写法不能照搬<br><strong>包装类Double-&gt;BigDecimal</strong><br>Double b&#x3D;38.0;<br>BigDecimal bd&#x3D;new BigDecimal(b.toString());&#x2F;&#x2F;最好不用（Java手册）<br>BigDecimal bp&#x3D;BigDecimal.valueOf(76.0);&#x2F;&#x2F;相比第八行这种写法更佳</p>
<p><strong>BigDecimal-&gt;包装类Double</strong><br>Double db&#x3D;bp.doubleValue();&#x2F;&#x2F;转为Double</p>
<p><strong>利用BigDecimal实现四则运算</strong><br>BigDecimal pp&#x3D;bd.add(bp);&#x2F;&#x2F;加法<br>        BigDecimal ppp&#x3D;bd.subtract(bp);&#x2F;&#x2F;减法<br>        BigDecimal pppb&#x3D;bd.multiply(bp);&#x2F;&#x2F;乘法<br>        BigDecimal pppp&#x3D;bd.divide(bp);&#x2F;&#x2F;除法<br>        &#x2F;&#x2F;因为BigDecimal写法要求得到具体值，若遇到1.0&#x2F;3.0这种就需要改为下面的写法<br>        BigDecimal p&#x3D;bd.divide(bp,2, RoundingMode.HALF_UP);&#x2F;&#x2F;保留两位，舍入</p>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><h5 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class outer&#123;</span><br><span class="line">    private int age=6;//-----&gt;outer.inner.age</span><br><span class="line">    public class inner&#123;</span><br><span class="line">        private int  age=3;//-----&gt;this.age</span><br><span class="line">        public void printAge()&#123;</span><br><span class="line">            int age=8;//-----&gt;age</span><br><span class="line">            System.out.println(age);//8</span><br><span class="line">            System.out.println(this.age);//3</span><br><span class="line">            System.out.println(outer.this.age);//6</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        outer.inner lei=new outer().new inner();</span><br><span class="line">        lei.printAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">outer.inner in=new Outer().new inner();</span><br></pre></td></tr></table></figure>
<h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class outer2&#123;</span><br><span class="line">    private int age=6;//-----&gt;outer.inner.age</span><br><span class="line">    public static class inner&#123;</span><br><span class="line">        private int  age=3;//-----&gt;this.age</span><br><span class="line">        public void printAge()&#123;</span><br><span class="line">            int age=8;//-----&gt;age</span><br><span class="line">            System.out.println(age);//8</span><br><span class="line">            System.out.println(this.age);//3</span><br><span class="line">            //System.out.println(outer2.this.age);//报错</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        outer2.inner lei=new outer2. inner();</span><br><span class="line">        lei.printAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">outer.inner in=new Outer.inner();</span><br></pre></td></tr></table></figure>
<h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><p>之前学接口实现类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface swimming&#123;</span><br><span class="line">    void swim();</span><br><span class="line">&#125;</span><br><span class="line">class A implements swimming&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void swim() &#123;</span><br><span class="line">        System.out.println(&quot;A游得快&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class outer3 &#123;</span><br><span class="line">    public  void swimFast(swimming sm)&#123;</span><br><span class="line">        sm.swim();</span><br><span class="line">    &#125;</span><br><span class="line">    public  static void main(String[] args) &#123;</span><br><span class="line">        outer3 outer3=new outer3();</span><br><span class="line">        swimming s=new A();//注意平时若使用多态写法不能使用子类独有功能与方法</span><br><span class="line">        outer3.swimFast(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在使用匿名内部类，可以少创建一个实现类，main函数可写为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public  static void main(String[] args) &#123;</span><br><span class="line">        outer3 outer3=new outer3();</span><br><span class="line">        swimming s2=new swimming() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void swim() &#123;</span><br><span class="line">                System.out.println(&quot;B游得快&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        outer3.swimFast(s2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可进一步简化为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public  static void main(String[] args) &#123;</span><br><span class="line">        outer3 outer3=new outer3();</span><br><span class="line">        outer3.swimFast(new swimming() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void swim() &#123;</span><br><span class="line">                System.out.println(&quot;C游得快&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">///学完Lambda表达式后可进一步简化为:outer3.swimFast(() -&gt; System.out.println(&quot;C游得快&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h4><pre><code>    int arr[]=new int[]&#123;11,22,33&#125;;
    //1.返回数组的内容
    System.out.println(Arrays.toString(arr));
    //2.原数组扩容，新增位默认为0
    int a2[]=Arrays.copyOf(arr,8);
    System.out.println(Arrays.toString(a2));
    //3.拷贝数组,左闭右开
    int a3[]=Arrays.copyOfRange(arr,0,2);
    System.out.println(Arrays.toString(a3));
    //4.setAll把原数据改为新数据又存进去
    double prices[]=new double[]&#123;25.0,17.0,36.0&#125;;
    Arrays.setAll(prices, new IntToDoubleFunction() &#123;//接口作为参数传入，匿名内部类
        @Override
        public double applyAsDouble(int value) &#123;
            BigDecimal price=BigDecimal.valueOf(prices[value]).multiply(BigDecimal.valueOf(0.8));
            return price.doubleValue();//把BigDemical转换为double类
        &#125;
    &#125;);
    //用Lambda表达式简化
    Arrays.setAll(prices, value -&gt; prices[value]*0.8 ); //继续简化
    //5.排序
    当排序的对象为自定义类
    Student[]student=new Student[]&#123;new Student(17, &quot;大明&quot;, 180.0),new Student(20, &quot;小红&quot;, 165.0),new Student(19, &quot;小刚&quot;, 170.0)&#125;;
    时，有以下两种处理法
    1.让对象的类实现Comparable接口
    （implements Comparable&lt;Student&gt;）
    ，然后重写compareTo接口(写在Student类里面的)，自定义排序规则（依照对象的什么参数进行排序）
    （ @Override
public int compareTo(Student o) &#123;
    return this.age-o.age;//升序
    //return o.age-this.age;//降序
&#125;//默认:左小于右，返回负数，左大于右，返回正数，左等于右，返回零，故为升序结果）
    Arrays.sort(students);
    System.out.println(Arrays.toString(students));
    System.out.println(&quot;-------&quot;);

    2.改写Arrays.sort()方法,调用Comparator比较器
    Arrays.sort(students, new Comparator&lt;Student&gt;() &#123;
        @Override
        public int compare(Student o1, Student o2) &#123;
            //return (int)(o1.getHeight()-o2.getHeight());//这样写会有问题，17.1-17.0他会认为是0，也就是二者相等
            return Double.compare(o1.getHeight(),o2.getHeight());//升序
            //return Double.compare(o2.getHeight(),o1.getHeight());//降序
        &#125;
    &#125;);
</code></pre>
<h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><pre><code>    Lambda表达式
1)作用:简化匿名内部类的代码
2)使用前提:只能简化函数式接口的匿名内部类
格式（被重写方法的形参列表）-&gt;&#123;被重写方法的方法体代码&#125;
注:1.函数式接口(有且仅有一个抽象方法的接口)
2.函数式接口大多存在一个为@Functionalinterface的注解
3)进一步简化(见ArraY类)
1.参数类型可以不写
2.如果只有一个参数，参数类型可以忽略，同时()也可以省略
3.如果Lambda表达式中方法体代码只是一行代码，可以省略大括号不写，同时省略分号，若为return语句，也必须去掉return语句
</code></pre>
<p>简化过程:<br>最初:<br>    Arrays.sort(students, new Comparator<Student>() {<br>            @Override<br>            public int compare(Student o1, Student o2) {<br>                return o1.getAge()- o2.getAge();&#x2F;&#x2F;<br>            }<br>        });<br>简化：<br>    Arrays.sort(students, (Student o1, Student o2) -&gt;return o1.getAge()- o2.getAge());<br>进一步：<br>    Arrays.sort(students, (Student o1, Student o2) -&gt; o1.getAge()- o2.getAge());</p>
<p>Lambda表达式在JDK8后的新特性–方法引用<br>先自己手写一个类CompareByData供方法一二简化<br>public class CompareByData {<br>    public static  int comparebyage(Student o1,Student o2){<br>            return o2.getAge()-o1.getAge();&#x2F;&#x2F;降序<br>    }<br>    public   int comparebyage1(Student o1,Student o2){<br>        return o2.getAge()-o1.getAge();&#x2F;&#x2F;降序<br>    }<br>}</p>
<ol>
<li>静态方法  若表达式只是引用一个static方法，且前后参数形式一致，就可使用静态方法引用<br>step1     Arrays.sort(students,(Student o1,Student o2)-&gt; o1.getAge()- o2.getAge());<br>step2     Arrays.sort(students,(Student o1,Student o2)-&gt;CompareByData.comparebyage(o1,o2));<br>step3     Arrays.sort(students,CompareByData::comparebyage);&#x2F;&#x2F;静态方法应用<br><strong>类::static方法</strong></li>
<li>实例方法 若表达式只是引用一个实例方法，且前后参数形式一致，就可使用静态方法引用<br>step1          CompareByData data&#x3D;new CompareByData();<br>step2          Arrays.sort(students,(Student o1,Student o2)-&gt;data.comparebyage1(o1,o2));<br>step3          Arrays.sort(students,data::comparebyage1);&#x2F;&#x2F;实例方法引用<br><strong>对象::实例方法</strong></li>
<li>特殊类型方法<br>若表达式<strong>只是引用一个实例方法，且参数列表第一个参数作为方法的主调</strong>，后面的参数都是作为这个实例方法的入参的，此时可以作为特定类型的方法引用<br><strong>T(泛型)::方法名</strong><br>例一<br>step1       Arrays.sort(names, new Comparator<String>() {<br>     @Override<br>     public int compare(String o1, String o2) {<br>         return o1.compareToIgnoreCase(o2);&#x2F;&#x2F;忽略大小写<br>     }<br> });</li>
</ol>
<p>step2        Arrays.sort(names, (String o1, String o2)-&gt;o1.compareToIgnoreCase(o2));<br>step3        Arrays.sort(names, String::compareToIgnoreCase);<br>例二<br>step1        Arrays.sort(students, new Comparator<Student>() {<br>            @Override<br>            public int compare(Student o1, Student o2) {<br>                return o1.compareTo(o2);<br>            }<br>        });<br>step2        Arrays.sort(students, Student::compareTo);<br>4. 构造器引用<br>如果某个表达式<strong>只是在创建对象，且前后参数情况一致</strong>，就可以使用构造器引用<br><strong>类名::new</strong><br>step1         createcar car&#x3D;new createcar() {<br>            @Override<br>            public Car create(String name, double price) {<br>                return new Car(name,price);<br>            }<br>        };<br>step2      createcar car&#x3D;(name,price)-&gt;{return new Car(name,price);};<br>step3      createcar car&#x3D;Car::new;<br> *&#x2F;            </p>
<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><h4 id="旧时间"><a href="#旧时间" class="headerlink" title="旧时间"></a>旧时间</h4><ol>
<li><strong>Date</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">两种构造器</span><br><span class="line">Date();</span><br><span class="line">Date(long time);</span><br><span class="line">常见方法</span><br><span class="line">        public void setTime(long time) &#123;</span><br><span class="line">            fastTime = time;</span><br><span class="line">            cdate = null;</span><br><span class="line">        &#125;</span><br><span class="line">        public long getTime() &#123;</span><br><span class="line">            return getTimeImpl();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
 使用： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Date date=new Date();//构造器1</span><br><span class="line">        System.out.println(date);//在2024//11/25 21:01运行得到 Mon Nov 25 21:01:00 CST 2024</span><br><span class="line">        long time=date.getTime();</span><br><span class="line">        System.out.println(time);//返回自1970.1.1至今走过的时间毫秒</span><br><span class="line">        time+=7*1000;</span><br><span class="line">        Date date1=new Date(time);//构造器2</span><br><span class="line">        System.out.println(date1);//得到7秒后的时间</span><br><span class="line">        System.out.println(&quot;----------&quot;);</span><br><span class="line">        System.out.println(date);//像别人写好的自定义类都重写了toString()这些</span><br><span class="line">        date.setTime(time);</span><br><span class="line">        System.out.println(date);//让date的时间变为变化后的而非一早的        </span><br></pre></td></tr></table></figure>
2.<strong>SimpleDateFormat</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">继承关系:</span><br><span class="line">public class SimpleDateFormat extends DateFormat</span><br><span class="line">常见构造器:</span><br><span class="line">SimpleDateFormat()//使用默认 FORMAT 区域设置的默认模式和日期格式符号构造 SimpleDateFormat</span><br><span class="line">SimpleDateFormat(String pattern)//使用给定的模式和默认 FORMAT locale的默认日期格式符号构造一个 SimpleDateFormat</span><br><span class="line">方法:</span><br><span class="line">1.格式化时间对象(时间-&gt;字符串)</span><br><span class="line">2.解析字符串中的时间为日期对象(字符串-&gt;时间)</span><br></pre></td></tr></table></figure>
 使用： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws ParseException &#123;</span><br><span class="line">        Date date=new Date();</span><br><span class="line">        long time=date.getTime();</span><br><span class="line">        //1.格式化时间对象(时间-&gt;字符串)</span><br><span class="line">        SimpleDateFormat sdf= new SimpleDateFormat(&quot;YYYY年MM月dd日 HH:mm:ss EEE a&quot;);</span><br><span class="line">        //2024年11月25日 21:28:22 星期一</span><br><span class="line">        String rs1=sdf.format(date);</span><br><span class="line">        String rs2=sdf.format(time);</span><br><span class="line">        System.out.println(rs1);</span><br><span class="line">        System.out.println(rs2);//两行打印出来是一样的</span><br><span class="line">        System.out.println(&quot;---------&quot;);</span><br><span class="line">        //2.解析字符串中的时间为日期对象(字符串-&gt;时间)</span><br><span class="line">        String rs3=&quot;2024-11-25 21:31:00&quot;;</span><br><span class="line">        SimpleDateFormat sdf2=new SimpleDateFormat(&quot;YYYY-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        Date date2=sdf2.parse(rs3);//上面两行格式要一致，否则抛异常</span><br><span class="line">        System.out.println(date2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
3.<strong>calendar</strong><br>继承关系:<br>public abstract class Calendar implements Serializable, Cloneable, Comparable<Calendar>{};<br><a target="_blank" rel="noopener" href="https://imgse.com/i/pEA8pl9"><img src="https://s21.ax1x.com/2025/01/21/pEA8pl9.png" alt="pEA8pl9.png"></a><br>使用：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Calendar ca=Calendar.getInstance();//获取当前日历对象</span><br><span class="line">        System.out.println(ca);//Shanghai指的是上海时区</span><br><span class="line">        int year=ca.get(Calendar.YEAR);//获取日历的某个信息</span><br><span class="line">        System.out.println(year);</span><br><span class="line">        int days=ca.get(Calendar.DATE);</span><br><span class="line">        System.out.println(days);</span><br><span class="line">        int day=ca.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">        System.out.println(day);//这一年的第多少天</span><br><span class="line">        Date date=ca.getTime();//日期对象</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        long time=ca.getTimeInMillis();//毫秒值</span><br><span class="line">        System.out.println(time);</span><br><span class="line">        //变化一些值</span><br><span class="line">        ca.set(Calendar.MONTH,9);//他是从0开始记录的，此时是修改成了10月份,输出里面还是MONTH=9</span><br><span class="line">        System.out.println(ca);</span><br><span class="line">        ca.add(Calendar.DAY_OF_YEAR,100);</span><br><span class="line">        ca.add(Calendar.DAY_OF_MONTH,1);</span><br><span class="line">        ca.add(Calendar.HOUR,4);</span><br><span class="line">        System.out.println(ca);</span><br><span class="line">        &#125;</span><br><span class="line">//注：它的对象为可变对象，修改后原先存储的内容数据就会消失</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="JDK8开始的新时间"><a href="#JDK8开始的新时间" class="headerlink" title="JDK8开始的新时间"></a>JDK8开始的新时间</h4><h5 id="搞清楚为什么要用JDK-8开始新增的时间类"><a href="#搞清楚为什么要用JDK-8开始新增的时间类" class="headerlink" title="搞清楚为什么要用JDK 8开始新增的时间类"></a>搞清楚为什么要用JDK 8开始新增的时间类</h5><p><img src="https://s1.imagehub.cc/images/2025/02/06/eb0e0cbf116251ead24ff402b9bf5cdb.png" alt="Snipaste 2025 02 06 22 01 12"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 传统的时间类（Date、SimpleDateFormat、Calendar）存在如下问题：</span><br><span class="line">        // 1、设计不合理，使用不方便，很多都被淘汰了。</span><br><span class="line">        Date d = new Date();</span><br><span class="line">        //System.out.println(d.getYear() + 1900);</span><br><span class="line"></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        int year = c.get(Calendar.YEAR);</span><br><span class="line">        System.out.println(year);</span><br><span class="line">        // 2、都是可变对象，修改后会丢失最开始的时间信息。</span><br><span class="line">        // 3、线程不安全。</span><br><span class="line">        // 4、不能精确到纳秒，只能精确到毫秒。</span><br><span class="line">            // 1秒 = 1000毫秒</span><br><span class="line">            // 1毫秒 = 1000微妙</span><br><span class="line">            // 1微妙 = 1000纳秒</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>新时间学习路线</strong><br><img src="https://s1.imagehub.cc/images/2025/02/06/b00a35c6e66ba4d73895de30a6490105.png" alt="Snipaste 2025 02 06 22 01 45"></p>
<h5 id="Step1-代替Calendar1Date"><a href="#Step1-代替Calendar1Date" class="headerlink" title="Step1 代替Calendar1Date"></a>Step1 代替Calendar1Date</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">public class InsteadCalendar1Date &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //LocalDate获取对象法一</span><br><span class="line">        LocalDate ld=LocalDate.now();//代表本地日期(年、月、日、星期),是不可变对象</span><br><span class="line">        LocalDate ldof = LocalDate.of(2026,6,7);</span><br><span class="line">        /*</span><br><span class="line">        方法名                                             说明</span><br><span class="line">        public int geYear() 获取年</span><br><span class="line">        public int getMonthValue() 获取月份（1-12）</span><br><span class="line">        public int getDayOfMonth() 获取日</span><br><span class="line">        public int getDayOfYear() 获取当前是一年中的第几天</span><br><span class="line">        Public DayOfWeek getDayOfWeek() 获取星期几：ld.getDayOfWeek().getValue()</span><br><span class="line">        方法名                                             说明</span><br><span class="line">        withYear、withMonth、withDayOfMonth、withDayOfYear 直接修改某个信息，返回新日期对象</span><br><span class="line">        plusYears、plusMonths、plusDays、plusWeeks 把某个信息加多少，返回新日期对象</span><br><span class="line">        minusYears、minusMonths、minusDays，minusWeeks 把某个信息减多少，返回新日期对象</span><br><span class="line">        equals isBefore isAfter   判断两个日期对象，是否相等，在前还是在后</span><br><span class="line">         */</span><br><span class="line">        System.out.println(ldof);//2026-06-07</span><br><span class="line">        System.out.println(ld);//2025-02-06</span><br><span class="line">        System.out.println(ld.getYear());//2025</span><br><span class="line">        System.out.println(ld.getMonthValue());//2</span><br><span class="line">        System.out.println(ld.getDayOfMonth());//6</span><br><span class="line">        System.out.println(ld.getDayOfYear());//37</span><br><span class="line">        System.out.println(ld.getDayOfWeek().getValue());//4</span><br><span class="line">        LocalDate ld2 = ld.withYear(2036);</span><br><span class="line">        System.out.println(ld2);//2036-02-06</span><br><span class="line">        System.out.println(ld.plusMonths(2).isBefore(ld2));//确实在前面，返回true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class InsteadCalendar2Time &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LocalTime lt=LocalTime.now();//代表本地时间(时、分、秒、纳秒),是不可变对象</span><br><span class="line">        LocalTime ltof = LocalTime.of(7, 3,2,7000000);</span><br><span class="line">        System.out.println(ltof);//07:03:02.007</span><br><span class="line">        System.out.println(lt);//23:14:43.989</span><br><span class="line">        System.out.println(lt.getHour());//23</span><br><span class="line">        System.out.println(lt.getMinute());//14</span><br><span class="line">        System.out.println(lt.getSecond());//43</span><br><span class="line">        System.out.println(lt.getNano());//989000000</span><br><span class="line">        //修改with,加plus,减minus,判断相等在前在后也一样</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class InsteadCalendar3DateTime &#123;</span><br><span class="line">    //也是两种获取对象的方法，其他方法也大差不差，就多了个转化</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LocalDateTime ldt=LocalDateTime.now();//代表本地日期、时间(年、月、日、星期、时、分、秒、纳秒),是不可变对象</span><br><span class="line">        LocalDateTime ldtof = LocalDateTime.of(ldt.toLocalDate(), ldt.toLocalTime());</span><br><span class="line">        System.out.println(ldtof);//2025-02-06T23:19:08.448</span><br><span class="line">        //LocalDateTime的转换成LocalDate、LocalTime</span><br><span class="line">        System.out.println(ldt);//2025-02-06T23:19:08.448</span><br><span class="line">        System.out.println(ldt.toLocalDate());//2025-02-06</span><br><span class="line">        System.out.println(ldt.toLocalTime());//23:19:08.448</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class InsteadCalendar4ZoneIdZonedDateTime &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //ZoneId</span><br><span class="line">            //法一 默认时区</span><br><span class="line">        ZoneId zi=ZoneId.systemDefault();</span><br><span class="line">        System.out.println(zi);//Asia/Shanghai  输出一致是因为它的toString方法调用了getId();</span><br><span class="line">        System.out.println(zi.getId());//Asia/Shanghai</span><br><span class="line">            //法二 所有时区</span><br><span class="line">        System.out.println(ZoneId.getAvailableZoneIds());</span><br><span class="line">        //ZoneId.getAvailableZoneIds().forEach( s-&gt;System.out.print(s+&quot;  &quot;));</span><br><span class="line">            //法三  指定时区</span><br><span class="line">        ZoneId zof = ZoneId.of(&quot;America/Marigot&quot;);</span><br><span class="line">        System.out.println(zof);//America/Marigot</span><br><span class="line">        System.out.println(&quot;-------&quot;);</span><br><span class="line"></span><br><span class="line">        //ZonedDateTime</span><br><span class="line">        System.out.println(ZonedDateTime.now(Clock.systemUTC()));//获取的是标准时间2025-02-06T15:42:01.556Z</span><br><span class="line">        System.out.println(ZonedDateTime.now());//获取的是系统默认时区的时间</span><br><span class="line">        ZonedDateTime zd1 = ZonedDateTime.now(ZoneId.of(&quot;Africa/Cairo&quot;));</span><br><span class="line">            //后面的和LocalDateTime大差不差</span><br><span class="line">        System.out.println(zd1);//2025-02-06T17:42:01.553+02:00[Africa/Cairo]</span><br><span class="line">        System.out.println(zd1.getHour());//17</span><br><span class="line">        System.out.println(zd1.plusMonths(7));//2025-09-06T17:42:01.553+03:00[Africa/Cairo]</span><br><span class="line">        //补充：Calendar中也可使用时区，但使用之后会变化,而且API也不好用</span><br><span class="line">        //Calendar instance = Calendar.getInstance(TimeZone.getTimeZone(zof));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Step2-代替Date"><a href="#Step2-代替Date" class="headerlink" title="Step2 代替Date"></a>Step2 代替Date</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class InsteadDate &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Instant is = Instant.now();</span><br><span class="line">        int nano = is.getNano();//从时间线开始，获取从第二个开始的纳秒数</span><br><span class="line">        long epochSecond = is.getEpochSecond();//获取从1970-01-01T00：00：00开始记录的秒数。</span><br><span class="line">        System.out.println(is);</span><br><span class="line">        System.out.println(epochSecond);</span><br><span class="line">        System.out.println(nano);</span><br><span class="line">        System.out.println(is.plusNanos(1000));</span><br><span class="line">        System.out.println(is.equals(Instant.now()));</span><br><span class="line">        System.out.println(nano);//前后不变</span><br><span class="line">        //用途：可以用来记录代码的执行时间，或用于记录用户操作某个事件的时间点。</span><br><span class="line">        Instant is2=Instant.now();</span><br><span class="line">        //...程序</span><br><span class="line">        Instant is3=Instant.now();</span><br><span class="line">        /*</span><br><span class="line">        传统的Date类，只能精确到毫秒，并且是可变对象；</span><br><span class="line">        新增的Instant类，可以精确到纳秒，并且是不可变对象，推荐用Instant代替Date。</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Step3-代替SimpleDateFormat"><a href="#Step3-代替SimpleDateFormat" class="headerlink" title="Step3 代替SimpleDateFormat"></a>Step3 代替SimpleDateFormat</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class InsteadSimpleDateFormat &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //避免线程不安全</span><br><span class="line">        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy年MM年dd日 HH:mm:ss&quot;);//时间格式化器</span><br><span class="line">        System.out.println(dateTimeFormatter.format(ZonedDateTime.now(ZoneId.systemDefault())));//</span><br><span class="line">        System.out.println(dateTimeFormatter.format(LocalDateTime.now()));</span><br><span class="line">        //LocalDateTime提供的格式化、解析时间的方法</span><br><span class="line">        System.out.println(LocalDateTime.now().format(dateTimeFormatter));</span><br><span class="line">          //解析</span><br><span class="line">        String rs=&quot;2025年02年07日 20:34:13&quot;;</span><br><span class="line">        System.out.println(LocalDateTime.parse(rs,dateTimeFormatter));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Step4-补充：Period-Duration"><a href="#Step4-补充：Period-Duration" class="headerlink" title="Step4 补充：Period,Duration"></a>Step4 补充：Period,Duration</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class MorePeriod &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //可以用于计算两个 LocalDate对象 相差的年数、月数、天数</span><br><span class="line">        LocalDate start = LocalDate.now();</span><br><span class="line">        LocalDate end = LocalDate.of(2025, 7, 6);</span><br><span class="line">        Period between = Period.between(start, end);</span><br><span class="line">        System.out.println(between.getYears());//0</span><br><span class="line">        System.out.println(between.getMonths());//4</span><br><span class="line">        System.out.println(between.getDays());//29  是相减后剩下不足一月的天数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MoreDuration &#123;</span><br><span class="line">    //可以用于计算两个时间对象相差的天数、小时数、分数、秒数、纳秒数；支持LocalTime、LocalDateTime、Instant</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LocalTime start =LocalTime.now();</span><br><span class="line">        LocalTime end = LocalTime.of(22, 49, 56);</span><br><span class="line">        Instant now = Instant.now();</span><br><span class="line">        Instant instant = now.plusMillis(1000000);</span><br><span class="line">        Duration d=Duration.between(now,instant);</span><br><span class="line">        System.out.println(d.toMinutes());</span><br><span class="line">        Duration between = Duration.between(start, end);</span><br><span class="line">        System.out.println(between.toDays());</span><br><span class="line">        System.out.println(between.toHours());</span><br><span class="line">        System.out.println(between.toMinutes());</span><br><span class="line">        System.out.println(between.toMillis());//计算隔多少毫秒，并返回</span><br><span class="line">        System.out.println(between.toNanos());//计算隔多少纳秒，并返回</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>注：</p>
<pre><code>  javac      java
</code></pre>
<p>.java——-&gt;.class——&gt;送到虚拟机运行（+核心类库）<br> 反编译可用cmd在终端javap .class文件<br><img src="https://s1.imagehub.cc/images/2025/02/04/52bdaad935599cdcd9835c7f02563220.png" alt="Snipaste 2025 02 04 13 54 05"><br><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/Snipaste-2025-02-04-13-38-25.Coss6s"><img src="https://s1.imagehub.cc/images/2025/02/04/757fe88f94e7c1e18ed2a2cb1a888933.png" alt="Snipaste 2025 02 04 13 38 25"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public enum A &#123;</span><br><span class="line">    x,y,z;//枚举类的第一行只能罗列一些名称，这些名称都是常量，</span><br><span class="line">    // 并且每个常量记住的都是枚举类的一个对象。</span><br><span class="line">    private int age;</span><br><span class="line">    A() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//补充：抽象枚举</span><br><span class="line">public  enum B &#123;//和一般类不一样此处不加abstract</span><br><span class="line">    //x;//抽象类不能直接创建对象，子类继承多态或者匿名内部类</span><br><span class="line">    x() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void go() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,y(&quot;张三&quot;) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void go() &#123;</span><br><span class="line">            System.out.println(getName()+&quot;在走&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    B() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    B(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    public abstract void go();//抽象方法没有方法体</span><br><span class="line">    &#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //不能创建对象</span><br><span class="line">        //A a1=new A();</span><br><span class="line">        A a=A.x;</span><br><span class="line">        a.setAge(8);</span><br><span class="line">        System.out.println(a.getAge());//8</span><br><span class="line">        System.out.println(a);//x</span><br><span class="line">        A[]b=A.values();//获取所有</span><br><span class="line">        System.out.println(Arrays.toString(b));//[x, y, z]</span><br><span class="line">        A c=A.valueOf(&quot;z&quot;);//根据字符找常量</span><br><span class="line">        System.out.println(c.name());//z</span><br><span class="line">        System.out.println(c.ordinal());//返回索引2</span><br><span class="line">        System.out.println(&quot;---------&quot;);</span><br><span class="line">        B d=B.y;</span><br><span class="line">        System.out.println(d);//y</span><br><span class="line">        d.go();//张三在走</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//多学一招：用枚举实现单例设计模式</span><br><span class="line">public enum C &#123;</span><br><span class="line">    x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举的应用场景<br><img src="https://s1.imagehub.cc/images/2025/02/04/89dfd12023b9df942790165096d10ac7.png" alt="Snipaste 2025 02 04 18 14 32"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public enum Sex &#123;</span><br><span class="line">    x,y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class AppEnum &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Sex a=Sex.x;</span><br><span class="line">        check(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void check(Sex sex)&#123;</span><br><span class="line">        switch (sex)&#123;</span><br><span class="line">            case x://在 Java 中，当使用 switch 语句处理枚举类型时，</span><br><span class="line">                // case 标签必须使用枚举常量的未限定名称。这意味着你不应该在枚举常量前加上枚举类型的名称</span><br><span class="line">                System.out.println(&quot;nba球星&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case y:</span><br><span class="line">                System.out.println(&quot;女明星&quot;);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>定义类、接口、方法时，同时声明了一个或者多个类型变量如：&lt;**E**&gt; ，称为泛型类、泛型接口，泛型方法、它们统称为<br>泛型。&#x2F;&#x2F;jdk1.7开始支持后面的数据类型可以不声明<br>作用：泛型提供了在编译阶段约束所能操作的数据类型，并自动进行检查的能力！这样可以避免强制类型转换，及其可能出现的异常。<br>泛型<br>泛型的本质：把具体的数据类型作为参数传给类型变量。</p>
<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>修饰符 class 类名&lt;类型变量，类型变量，…&gt;<br>{<br>}<br>注意：类型变量建议用大写的英文字母，常用的有：E、T、K、V 等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">//泛型类</span><br><span class="line">public class MyArrayList&lt;E&gt;&#123;</span><br><span class="line">    Object[]obj=new Object[10];</span><br><span class="line">    private int size;</span><br><span class="line">    public MyArrayList() &#123;</span><br><span class="line">        this.size = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getSize() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setSize(int size) &#123;</span><br><span class="line">        this.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean add(E e)&#123;</span><br><span class="line">        if(this.size&gt;=obj.length)&#123;</span><br><span class="line">            obj=Arrays.copyOf(obj,size*2);</span><br><span class="line">        &#125;</span><br><span class="line">        obj[size] = e;</span><br><span class="line">        size++;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public E getE(int index)&#123;</span><br><span class="line">        if(index&gt;=0&amp;&amp;index &lt; size) &#123;</span><br><span class="line">            return (E)obj[index];</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">public class MyClass2&lt;E,T&gt; &#123;</span><br><span class="line">    public void put(E e,T t)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public MyClass2()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class MyClass3&lt;E extends Animal&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line">public class MyClass4 &lt;Animal&gt;&#123;//错误写法，并非是</span><br><span class="line">//    要求必须是Animal类了，而是把它当作E,继承Object类了</span><br><span class="line">//    参数可以随便写，应按照MyClass3那样写</span><br><span class="line">&#125;</span><br><span class="line">public class Animal &#123;</span><br><span class="line">&#125;</span><br><span class="line">public class Dog extends Animal&#123;</span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyArrayList list2=new MyArrayList();//若不使用泛型都是object类型</span><br><span class="line">        MyArrayList&lt;String&gt;list=new MyArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;7&quot;);</span><br><span class="line">        list.add(&quot;8&quot;);</span><br><span class="line">        System.out.println(list.getE(0));</span><br><span class="line">        MyClass2&lt;Animal,String&gt;my2=new MyClass2&lt;&gt;();</span><br><span class="line">        //MyClass3&lt;String&gt;wrong=new MyClass3&lt;&gt;();//会报错，泛型类型不是animal或其子类</span><br><span class="line">        MyClass3&lt;Animal&gt;m3=new MyClass3&lt;&gt;();</span><br><span class="line">        MyClass3&lt;Dog&gt;m33=new MyClass3&lt;&gt;();</span><br><span class="line">        MyClass4&lt;String&gt;m4=new MyClass4&lt;&gt;();//不报错,参数随便写，因为泛型都搞错了</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>修饰符 interface 接口名&lt;类型变量，类型变<br>量，…&gt; {<br>}<br> 注意：类型变量建议用大写的英文字母，常用的有：E、T、K、V 等<br>和泛型类差不多，一个&#x2F;多个&#x2F;受限制继承</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 目标：掌握泛型接口的定义和使用。</span><br><span class="line"> // 场景：系统需要处理学生和老师的数据，需要提供2个功能：保存对象数据。根据名称查询数据。</span><br><span class="line">public interface Data &lt;E &gt;&#123;</span><br><span class="line">    void add(E e);</span><br><span class="line">    ArrayList&lt;E&gt; getByName(E e);</span><br><span class="line">&#125;</span><br><span class="line">public class StudentData implements Data&lt;Student&gt;&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add(Student student) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ArrayList&lt;Student&gt; getByName(Student student) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TeacherData implements Data&lt;Teacher&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void add(Teacher teacher) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ArrayList&lt;Teacher&gt; getByName(Teacher teacher) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Student &#123;</span><br><span class="line">&#125;</span><br><span class="line">public class Teacher &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型方法、泛型通配符、上下限"><a href="#泛型方法、泛型通配符、上下限" class="headerlink" title="泛型方法、泛型通配符、上下限"></a>泛型方法、泛型通配符、上下限</h4><p>自己定义泛型变量的才是泛型方法，哪怕是用的自己所在泛型类所给的类型的都不算泛型方法，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyArrayList&lt;E&gt;&#123;</span><br><span class="line">  ......</span><br><span class="line">public E getE(int index)&#123;</span><br><span class="line">        if(index&gt;=0&amp;&amp;index &lt; size) &#123;</span><br><span class="line">            return (E)obj[index];</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>就不算泛型方法<br>例一</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Dog &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public Dog() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public Dog(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;狗的名字是&quot;+this.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">修饰符 (static)&lt;类型变量，类型变量，…&gt; 返回值类型 方法名(形参列</span><br><span class="line">        表) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"> */</span><br><span class="line">public class Test1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test1();</span><br><span class="line">        System.out.println(test2(3));//3</span><br><span class="line">        System.out.println(test3(8));//8</span><br><span class="line">        System.out.println(test3(&quot;java&quot;));//java</span><br><span class="line">        System.out.println(test3(new Dog(&quot;哈哈哈&quot;)));//狗的名字是哈哈哈</span><br><span class="line">    &#125;</span><br><span class="line">    public static &lt;N&gt; void test1()&#123;</span><br><span class="line">    &#125;//泛型无意义</span><br><span class="line">    public static &lt;N&gt; int test2(int c)&#123;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;//泛型无意义</span><br><span class="line">    public static &lt;N&gt; N test3(N n)&#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例二</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class Car &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class BENZ extends Car&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class BMW extends Car&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class Test2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;BENZ&gt;benCars=new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;BMW&gt;bmwCars=new ArrayList&lt;&gt;();</span><br><span class="line">        //go(benCars);会报错！只是方法的参数是泛型类对象&lt;Car&gt;的子类</span><br><span class="line">        go1(benCars);</span><br><span class="line">        go1(bmwCars);</span><br><span class="line">        go1(new ArrayList&lt;Dog&gt;());//也不报错，所以要限制E</span><br><span class="line">        go2(new BENZ());</span><br><span class="line">        go2(new BMW());//不报错，就是多态写法，与go要区分开!</span><br><span class="line">        go3(benCars);</span><br><span class="line">        go3(bmwCars);</span><br><span class="line">        go3(new ArrayList&lt;Car&gt;());</span><br><span class="line">        //go3(new ArrayList&lt;Dog&gt;());//报错了</span><br><span class="line">        /*</span><br><span class="line">        Required type:ArrayList&lt;E&gt; Provided:ArrayList&lt;Dog&gt;</span><br><span class="line">         */</span><br><span class="line">        go4(new ArrayList&lt;Dog&gt;());//不报错</span><br><span class="line">        //go5(new ArrayList&lt;Dog&gt;());//会报错了</span><br><span class="line">    &#125;</span><br><span class="line">    public static void go(ArrayList&lt;Car&gt; car)&#123;//点名道姓了参数具体要求，子类当然不行了</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static&lt;E&gt; void go1(ArrayList&lt;E&gt; cars)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void go2(Car cars)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static&lt;E extends Car&gt; void go3(ArrayList&lt;E&gt; cars)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    使用通配符简化</span><br><span class="line">     */</span><br><span class="line">    public static&lt;E extends Car&gt; void go4(ArrayList&lt;?&gt; cars)&#123;</span><br><span class="line">    &#125;//可以在“使用泛型”的时候代表一切类型</span><br><span class="line">    public static&lt;E extends Car&gt; void go5(ArrayList&lt;? extends Car&gt; cars)&#123;</span><br><span class="line">    &#125;//泛型上限: ? extends Car: ? 能接收的必须是Car或者其子类 。</span><br><span class="line">    public static&lt;E extends Car&gt; void go6(ArrayList&lt; ? super Car&gt; cars)&#123;</span><br><span class="line">    &#125;//泛型下限： ? super Car ： ? 能接收的必须是Car或者其父类。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型的注意事项：擦除问题、基本数据类型问题"><a href="#泛型的注意事项：擦除问题、基本数据类型问题" class="headerlink" title="泛型的注意事项：擦除问题、基本数据类型问题"></a>泛型的注意事项：擦除问题、基本数据类型问题</h4><p>泛型的擦除问题和注意事项<br> 泛型是工作在编译阶段的，一旦程序编译成class文件，class文件中就不存在泛型了，这就是泛型擦除。<br><img src="https://s1.imagehub.cc/images/2025/02/06/f38bf61b80d52c513b55310b133a9d0a.png" alt="Snipaste 2025 02 06 21 32 33"><br> 泛型不支持基本数据类型，只能支持对象类型（引用数据类型）。</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">public class RegexTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 1、字符类(只能匹配单个字符)</span><br><span class="line">        System.out.println(&quot;a&quot;.matches(&quot;[abc]&quot;));    // [abc]只能匹配a、b、c</span><br><span class="line">        System.out.println(&quot;e&quot;.matches(&quot;[abcd]&quot;)); // false</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;d&quot;.matches(&quot;[^abc]&quot;));   // [^abc] 不能是abc</span><br><span class="line">        System.out.println(&quot;a&quot;.matches(&quot;[^abc]&quot;));  // false</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;b&quot;.matches(&quot;[a-zA-Z]&quot;)); // [a-zA-Z] 只能是a-z A-Z的字符</span><br><span class="line">        System.out.println(&quot;2&quot;.matches(&quot;[a-zA-Z]&quot;)); // false</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;k&quot;.matches(&quot;[a-z&amp;&amp;[^bc]]&quot;)); // ： a到z，除了b和c</span><br><span class="line">        System.out.println(&quot;b&quot;.matches(&quot;[a-z&amp;&amp;[^bc]]&quot;)); // false</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;ab&quot;.matches(&quot;[a-zA-Z0-9]&quot;)); // false 注意：以上带 [内容] 的规则都只能用于匹配单个字符</span><br><span class="line">        System.out.println(&quot;-------------&quot;);</span><br><span class="line">        // 2、预定义字符(只能匹配单个字符)  .  \d  \D   \s  \S  \w  \W</span><br><span class="line">        System.out.println(&quot;徐&quot;.matches(&quot;.&quot;)); // .可以匹配任意字符</span><br><span class="line">        System.out.println(&quot;徐徐&quot;.matches(&quot;.&quot;)); // false</span><br><span class="line"></span><br><span class="line">        // \转义</span><br><span class="line">        System.out.println(&quot;\&quot;&quot;);</span><br><span class="line">        // \n \t</span><br><span class="line">        System.out.println(&quot;3&quot;.matches(&quot;\\d&quot;));  // \d: 0-9</span><br><span class="line">        System.out.println(&quot;a&quot;.matches(&quot;\\d&quot;));  //false</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot; &quot;.matches(&quot;\\s&quot;));   // \s: 代表一个空白字符</span><br><span class="line">        //System.out.println(&quot;a&quot;.matches(&quot;\s&quot;)); // false</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;a&quot;.matches(&quot;\\S&quot;));  // \S: 代表一个非空白字符</span><br><span class="line">        System.out.println(&quot; &quot;.matches(&quot;\\S&quot;)); // false</span><br><span class="line">        System.out.println(&quot;a&quot;.matches(&quot;\\w&quot;));  // \w: [a-zA-Z_0-9]</span><br><span class="line">        System.out.println(&quot;_&quot;.matches(&quot;\\w&quot;)); // true</span><br><span class="line">        System.out.println(&quot;徐&quot;.matches(&quot;\\w&quot;)); // false</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;徐&quot;.matches(&quot;\\W&quot;));  // [^\w]不能是a-zA-Z_0-9</span><br><span class="line">        System.out.println(&quot;a&quot;.matches(&quot;\\W&quot;));  // false</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;23232&quot;.matches(&quot;\\d&quot;)); // false 注意：以上预定义字符都只能匹配单个字符。</span><br><span class="line"></span><br><span class="line">        // 3、数量词： ?   *   +   &#123;n&#125;   &#123;n, &#125;  &#123;n, m&#125;</span><br><span class="line">        System.out.println(&quot;a&quot;.matches(&quot;\\w?&quot;));   // ? 代表0次或1次</span><br><span class="line">        System.out.println(&quot;&quot;.matches(&quot;\\w?&quot;));    // true</span><br><span class="line">        System.out.println(&quot;abc&quot;.matches(&quot;\\w?&quot;)); // false</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;abc12&quot;.matches(&quot;\\w*&quot;));   // * 代表0次或多次</span><br><span class="line">        System.out.println(&quot;&quot;.matches(&quot;\\w*&quot;));        // true</span><br><span class="line">        System.out.println(&quot;abc12张&quot;.matches(&quot;\\w*&quot;)); // false</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;abc12&quot;.matches(&quot;\\w+&quot;));   // + 代表1次或多次</span><br><span class="line">        System.out.println(&quot;&quot;.matches(&quot;\\w+&quot;));       // false</span><br><span class="line">        System.out.println(&quot;abc12张&quot;.matches(&quot;\\w+&quot;)); // false</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;a3c&quot;.matches(&quot;\\w&#123;3&#125;&quot;));   // &#123;3&#125; 代表要正好是n次</span><br><span class="line">        System.out.println(&quot;abcd&quot;.matches(&quot;\\w&#123;3&#125;&quot;));  // false</span><br><span class="line">        System.out.println(&quot;abcd&quot;.matches(&quot;\\w&#123;3,&#125;&quot;));     // &#123;3,&#125; 代表是&gt;=3次</span><br><span class="line">        System.out.println(&quot;ab&quot;.matches(&quot;\\w&#123;3,&#125;&quot;));     // false</span><br><span class="line">        System.out.println(&quot;abcde徐&quot;.matches(&quot;\\w&#123;3,&#125;&quot;));     // false</span><br><span class="line">        System.out.println(&quot;abc232d&quot;.matches(&quot;\\w&#123;3,9&#125;&quot;));     // &#123;3, 9&#125; 代表是  大于等于3次，小于等于9次</span><br><span class="line"></span><br><span class="line">        // 4、其他几个常用的符号：(?i)忽略大小写 、 或：| 、  分组：()</span><br><span class="line">        System.out.println(&quot;abc&quot;.matches(&quot;(?i)abc&quot;)); // true</span><br><span class="line">        System.out.println(&quot;ABC&quot;.matches(&quot;(?i)abc&quot;)); // true</span><br><span class="line">        System.out.println(&quot;aBc&quot;.matches(&quot;a((?i)b)c&quot;)); // true</span><br><span class="line">        System.out.println(&quot;ABc&quot;.matches(&quot;a((?i)b)c&quot;)); // false</span><br><span class="line"></span><br><span class="line">        // 需求1：要求要么是3个小写字母，要么是3个数字。</span><br><span class="line">        System.out.println(&quot;abc&quot;.matches(&quot;[a-z]&#123;3&#125;|\\d&#123;3&#125;&quot;)); // true</span><br><span class="line">        System.out.println(&quot;ABC&quot;.matches(&quot;[a-z]&#123;3&#125;|\\d&#123;3&#125;&quot;)); // false</span><br><span class="line">        System.out.println(&quot;123&quot;.matches(&quot;[a-z]&#123;3&#125;|\\d&#123;3&#125;&quot;)); // true</span><br><span class="line">        System.out.println(&quot;A12&quot;.matches(&quot;[a-z]&#123;3&#125;|\\d&#123;3&#125;&quot;)); // false</span><br><span class="line"></span><br><span class="line">        // 需求2：必须是”我爱“开头，中间可以是至少一个”编程“，最后至少是1个”666“</span><br><span class="line">        System.out.println(&quot;我爱编程编程666666&quot;.matches(&quot;我爱(编程)+(666)+&quot;));</span><br><span class="line">        System.out.println(&quot;我爱编程编程66666&quot;.matches(&quot;我爱(编程)+(666)+&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p><a target="_blank" rel="noopener" href="https://imgse.com/i/pEA8mSH"><img src="https://s21.ax1x.com/2025/01/21/pEA8mSH.png" alt="pEA8mSH.png"></a><br><a target="_blank" rel="noopener" href="https://imgse.com/i/pEA8nld"><img src="https://s21.ax1x.com/2025/01/21/pEA8nld.png" alt="pEA8nld.png"></a><br><a target="_blank" rel="noopener" href="https://imgse.com/i/pEA8u6A"><img src="https://s21.ax1x.com/2025/01/21/pEA8u6A.png" alt="pEA8u6A.png"></a></p>
<h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><ol>
<li>常用方法<br><a target="_blank" rel="noopener" href="https://imgse.com/i/pEAWN34"><img src="https://s21.ax1x.com/2025/01/22/pEAWN34.png" alt="pEAWN34.png"></a><br>补充:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt;k1=new ArrayList();</span><br><span class="line">        Collection&lt;String&gt;k2=new ArrayList();</span><br><span class="line">        k1.add(&quot;666&quot;);</span><br><span class="line">        k2.add(&quot;777&quot;);</span><br><span class="line">        Object[] objects = k1.toArray();//无参</span><br><span class="line">        String[] strings = k1.toArray(new String[k1.size()]);//有参，全是同种类型的元素</span><br><span class="line">        k1.addAll(k2);//相当于是拷贝一份过来(全倒进来)</span><br><span class="line">        System.out.println(k1);//666,777</span><br></pre></td></tr></table></figure></li>
<li>遍历<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//方法一  迭代器</span><br><span class="line">        Iterator&lt;String&gt; iterator = k1.iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;//询问当前位置是否存在元素</span><br><span class="line">            System.out.println(iterator.next());//取当前位置元素，然后后移一位</span><br><span class="line">            //问一次取一次，不要每次问完取多次</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;-------------&quot;);</span><br><span class="line">        //方法二 增强for(本质上还是迭代器的增强)</span><br><span class="line">        for (String s : k1) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;-------------&quot;);</span><br><span class="line">        //普通for 略(有索引才能用！比如说List)</span><br><span class="line">        //方法四</span><br><span class="line">        k1.forEach(new Consumer&lt;String&gt;() &#123;//接口 interface Consumer&lt;T&gt;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(String s) &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(&quot;-------------&quot;);//简化</span><br><span class="line">        k1.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p><a target="_blank" rel="noopener" href="https://imgse.com/i/pEAWzV0"><img src="https://s21.ax1x.com/2025/01/22/pEAWzV0.png" alt="pEAWzV0.png"></a><br>ArrayList底层基于数组实现，具有以下特点:<br>1 根据索引查询数据快，查询任意数据耗时相同<br>2 删除效率低（左移）<br>3 添加效率低（右移，扩容）<br>适用场景：根据索引查询<br>不适合：数据大，同时还要进行增删操作<br><a target="_blank" rel="noopener" href="https://imgse.com/i/pEAfMGD"><img src="https://s21.ax1x.com/2025/01/22/pEAfMGD.png" alt="pEAfMGD.png"></a><br>LinkedList底层基于双链表实现，具有以下特点:<br>1 查询数据慢，需要从头开始找<br>2 删除，添加效率高（在首尾位置删除，添加效率极高）<br>新增了许多对首尾进行操作的特有方法：<br><a target="_blank" rel="noopener" href="https://imgse.com/i/pEAfQRe"><img src="https://s21.ax1x.com/2025/01/22/pEAfQRe.png" alt="pEAfQRe.png"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        // 1、创建一个队列。</span><br><span class="line">        LinkedList&lt;String&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        // 入队</span><br><span class="line">        queue.addLast(&quot;第1号人&quot;);</span><br><span class="line">        queue.addLast(&quot;第2号人&quot;);</span><br><span class="line">        queue.addLast(&quot;第3号人&quot;);</span><br><span class="line">        queue.addLast(&quot;第4号人&quot;);</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        // 出队</span><br><span class="line">        System.out.println(queue.removeFirst());</span><br><span class="line">        System.out.println(queue.removeFirst());</span><br><span class="line">        System.out.println(queue.removeFirst());</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        System.out.println(&quot;--------------------------------------------------&quot;);</span><br><span class="line">        // 2、创建一个栈对象。</span><br><span class="line">        LinkedList&lt;String&gt; stack = new LinkedList&lt;&gt;();</span><br><span class="line">        // 压栈(push)//源码就是addFirst</span><br><span class="line">        stack.push(&quot;第1颗子弹&quot;);</span><br><span class="line">        stack.push(&quot;第2颗子弹&quot;);</span><br><span class="line">        stack.push(&quot;第3颗子弹&quot;);</span><br><span class="line">        stack.push(&quot;第4颗子弹&quot;);</span><br><span class="line">        System.out.println(stack);</span><br><span class="line">        // 出栈(pop)//源码就是removeFirst</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>适用场景：1.设计队列（FIFO）2设计栈（FILO）</p>
<h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>HashSet:无序不重复无索引<br>LinkedHashSet:有序不重复无索引<br>TreeSet:默认升序不重复无索引<br>java所有对象都可调用object来提供的hashcode()方法得到哈希值,<br>其中:<br>1.同一对象多次调用hashcode()返回值相同<br>2.不同对象哈希值一般不同也可能相同,此时称为哈希碰撞</p>
<h6 id="HashSet底层原理-哈希表-数组-链表（-红黑树）"><a href="#HashSet底层原理-哈希表-数组-链表（-红黑树）" class="headerlink" title="HashSet底层原理:哈希表&#x3D;数组+链表（+红黑树）"></a>HashSet底层原理:哈希表&#x3D;数组+链表（+红黑树）</h6><p>哈希值对16求余，位置若为空则存入；位置若不为空，调用equals方法，若不等才存入，否则不存入<br>jdk8之前新元素存入数组，占老元素位置，老元素挂下面；<br>jdk8之后新元素直接挂在老元素下面。当集合中的元素数量超过 数组长度×加载因子 时，数组会进行扩容，扩容到原来的两倍，再把原数组中的元素全部转入到新数组中。若链表长度如果大于八，数组长度如果大于等于64，自动将链表转成红黑树，每个节点都会保存四个数据：本节点的值、父节点地址、左子节点地址和右子节点地址。</p>
<h6 id="LinkedHashSet底层原理-数组-链表-红黑树-每个元素增加了双链表机制记住前后元素的位置，因此有序"><a href="#LinkedHashSet底层原理-数组-链表-红黑树-每个元素增加了双链表机制记住前后元素的位置，因此有序" class="headerlink" title="LinkedHashSet底层原理:数组+链表+红黑树(每个元素增加了双链表机制记住前后元素的位置，因此有序)"></a>LinkedHashSet底层原理:数组+链表+红黑树(每个元素增加了双链表机制记住前后元素的位置，因此有序)</h6><h6 id="TreeSet底层原理-红黑树（按照大小默认升序，适用于包装类和字符串）"><a href="#TreeSet底层原理-红黑树（按照大小默认升序，适用于包装类和字符串）" class="headerlink" title="TreeSet底层原理:红黑树（按照大小默认升序，适用于包装类和字符串）"></a>TreeSet底层原理:红黑树（按照大小默认升序，适用于包装类和字符串）</h6><p>若数据类型为自定义类型时需要自己指定排序规则：<br>1.让对象的类实现Comparable接口<br>        （implements Comparable<T>）<br>        ，然后重写compareTo接口(写在自定义的T类里面的)，自定义排序规则（依照对象的什么参数进行排序）<br>        （ @Override<br>    public int compareTo(Student o) {<br>        return this.age-o.age;&#x2F;&#x2F;升序<br>        &#x2F;&#x2F;return o.age-this.age;&#x2F;&#x2F;降序<br>    }&#x2F;&#x2F;默认:左小于右，返回负数，左大于右，返回正数，左等于右，返回零，故为升序结果）<br>        2.一开始就使用有参构造器，调用Comparator比较器<br>        Set<Student>set&#x3D;new TreeSet&lt;&gt;(new Comparator<Student>() {<br>            @Override<br>            public int compare(Student o1, Student o2) {<br>                return Double.compare(o1.getHeight(),o2.getHeight());<br>            }<br>        }<br><strong>注：如果两种方法都使用了那按照第二种有参构造器里面的规则来。</strong></p>
<h5 id="并发修改异常"><a href="#并发修改异常" class="headerlink" title="并发修改异常"></a>并发修改异常</h5><p><strong>不能用增强for循环!</strong></p>
<ol>
<li>用for循环  要么删除后马上i–,要么倒着遍历 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i=0;i&lt; k1.size();i++) &#123;</span><br><span class="line">           if(k1.get(i).contains(&quot;6&quot;))&#123;</span><br><span class="line">               k1.remove(i);</span><br><span class="line">               i--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(k1);</span><br></pre></td></tr></table></figure></li>
<li>用迭代器<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = k1.iterator();</span><br><span class="line">while (it.hasNext()) &#123;//询问当前位置是否存在元素</span><br><span class="line">    if(it.next().contains(&quot;7&quot;))&#123;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(k1);</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><p><img src="https://s1.imagehub.cc/images/2025/01/22/a2c3752d206bf40d1121412c984d4a7d.png" alt="Snipaste 2025 01 22 23 45 26"><br><img src="https://s1.imagehub.cc/images/2025/01/22/2f2db2380d107af6cd50b7b7a06f55a5.png" alt="Snipaste 2025 01 22 23 45 11">        </p>
<h5 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h5><p><img src="https://s1.imagehub.cc/images/2025/01/22/2069a6227de234367c444692d10f26a4.png" alt="Snipaste 2025 01 22 23 49 55"><br><img src="https://s1.imagehub.cc/images/2025/01/22/b369e6dbcecbfbf336826993c3ce8447.png" alt="Snipaste 2025 01 22 23 54 55"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        // 1、public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T...elements)：为集合批量添加数据</span><br><span class="line">        List&lt;String&gt; names = new ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(names, &quot;张三&quot;, &quot;王五&quot;, &quot;李四&quot;, &quot;张麻子&quot;);</span><br><span class="line">        System.out.println(names);</span><br><span class="line"></span><br><span class="line">        // 2、public static void shuffle(List&lt;?&gt; list)：打乱List集合中的元素顺序。</span><br><span class="line">        Collections.shuffle(names);</span><br><span class="line">        System.out.println(names);</span><br><span class="line"></span><br><span class="line">        // 3、 public static &lt;T&gt; void sort(List&lt;T&gt; list)：对List集合中的元素进行升序排序。</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(3);</span><br><span class="line">        list.add(5);</span><br><span class="line">        list.add(2);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = new ArrayList&lt;&gt;();</span><br><span class="line">        students.add(new Student(&quot;蜘蛛精&quot;,23, 169.7));</span><br><span class="line">        students.add(new Student(&quot;紫霞&quot;,22, 169.8));</span><br><span class="line">        students.add(new Student(&quot;紫霞&quot;,22, 169.8));</span><br><span class="line">        students.add(new Student(&quot;至尊宝&quot;,26, 165.5));</span><br><span class="line">        // Collections.sort(students);//前提是自定义类已经实现了Comparable&lt;student&gt;接口</span><br><span class="line">        // System.out.println(students);</span><br><span class="line"></span><br><span class="line">        // 4、public static &lt;T&gt; void sort(List&lt;T&gt; list， Comparator&lt;? super T&gt; c): 对List集合中元素，按照比较器对象指定的规则进行排序</span><br><span class="line">        Collections.sort(students, new Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Student o1, Student o2) &#123;</span><br><span class="line">                return Double.compare(o1.getHeight(), o2.getHeight());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(students);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="Collection业务场景分析"><a href="#Collection业务场景分析" class="headerlink" title="Collection业务场景分析"></a>Collection业务场景分析</h5><p><a target="_blank" rel="noopener" href="https://imgse.com/i/pEAOwWR"><img src="https://s21.ax1x.com/2025/01/23/pEAOwWR.png" alt="pEAOwWR.png"></a></p>
<h4 id="Map-键值对集合"><a href="#Map-键值对集合" class="headerlink" title="Map(键值对集合)"></a>Map(键值对集合)</h4><h5 id="Map引入"><a href="#Map引入" class="headerlink" title="Map引入"></a>Map引入</h5><p>业务场景：存储一一对应的数据<br>键不允许重复，值可以重复<br>HashMap:无序不重复无索引<br>LinkedHashMap:有序不重复无索引<br>TreeMap:默认升序（按照键的大小）不重复无索引，自定义排序两种方法和TreeMap一样<br>实际上set就是map只要键不要值的情况，其他都一样<br><img src="https://s1.imagehub.cc/images/2025/01/23/22bcc5fde14b7a8a172500c94e746d0f.png" alt="Snipaste 2025 01 23 00 05 42"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        // 1.添加元素: 无序，不重复，无索引。</span><br><span class="line">        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;手表&quot;, 100);</span><br><span class="line">        map.put(&quot;手表&quot;, 220);</span><br><span class="line">        map.put(&quot;手机&quot;, 2);</span><br><span class="line">        map.put(&quot;Java&quot;, 2);</span><br><span class="line">        map.put(null, null);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        // map = &#123;null=null, 手表=220, Java=2, 手机=2&#125;</span><br><span class="line">        // 2.public int size():获取集合的大小</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">        // 3、public void clear():清空集合</span><br><span class="line">        //map.clear();</span><br><span class="line">        //System.out.println(map);</span><br><span class="line">        // 4.public boolean isEmpty(): 判断集合是否为空，为空返回true ,反之！</span><br><span class="line">        System.out.println(map.isEmpty());</span><br><span class="line">        // 5.public V get(Object key)：根据键获取对应值</span><br><span class="line">        int v1 = map.get(&quot;手表&quot;);</span><br><span class="line">        System.out.println(v1);</span><br><span class="line">        System.out.println(map.get(&quot;手机&quot;)); // 2</span><br><span class="line">        System.out.println(map.get(&quot;张三&quot;)); // null</span><br><span class="line">        // 6. public V remove(Object key)：根据键删除整个元素(删除键会返回键的值)</span><br><span class="line">        System.out.println(map.remove(&quot;手表&quot;));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        // 7.public  boolean containsKey(Object key): 判断是否包含某个键 ，包含返回true ,反之</span><br><span class="line">        System.out.println(map.containsKey(&quot;手表&quot;)); // false</span><br><span class="line">        System.out.println(map.containsKey(&quot;手机&quot;)); // true</span><br><span class="line">        System.out.println(map.containsKey(&quot;java&quot;)); // false</span><br><span class="line">        System.out.println(map.containsKey(&quot;Java&quot;)); // true</span><br><span class="line">        // 8.public boolean containsValue(Object value): 判断是否包含某个值。</span><br><span class="line">        System.out.println(map.containsValue(2)); // true</span><br><span class="line">        System.out.println(map.containsValue(&quot;2&quot;)); // false</span><br><span class="line">        // 9.public Set&lt;K&gt; keySet(): 获取Map集合的全部键。</span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        System.out.println(keys);</span><br><span class="line">        // 10.public Collection&lt;V&gt; values(); 获取Map集合的全部值。</span><br><span class="line">        Collection&lt;Integer&gt; values = map.values();</span><br><span class="line">        System.out.println(values);</span><br><span class="line">        // 11.把其他Map集合的数据倒入到自己集合中来。(拓展)</span><br><span class="line">        Map&lt;String, Integer&gt; map1 = new HashMap&lt;&gt;();</span><br><span class="line">        map1.put(&quot;java1&quot;,  10);</span><br><span class="line">        map1.put(&quot;java2&quot;,  20);</span><br><span class="line">        Map&lt;String, Integer&gt; map2 = new HashMap&lt;&gt;();</span><br><span class="line">        map2.put(&quot;java3&quot;,  10);</span><br><span class="line">        map2.put(&quot;java2&quot;,  222);</span><br><span class="line">        map1.putAll(map2); // putAll：把map2集合中的元素全部倒入一份到map1集合中去。</span><br><span class="line">        System.out.println(map1);</span><br><span class="line">        System.out.println(map2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="Map遍历"><a href="#Map遍历" class="headerlink" title="Map遍历"></a>Map遍历</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;String,Integer&gt;map1=new HashMap&lt;&gt;();</span><br><span class="line">        map1.put(&quot;蜘蛛精&quot;,187);</span><br><span class="line">        map1.put(&quot;地藏&quot;,186);</span><br><span class="line">        /*</span><br><span class="line">        方法一  键找值</span><br><span class="line">         */</span><br><span class="line">        Set&lt;String&gt;set= map1.keySet();</span><br><span class="line">        set.forEach(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(String s) &#123;</span><br><span class="line">                int value= map1.get(s);</span><br><span class="line">                System.out.println(s+&quot;-----&gt;&quot;+value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(&quot;--------------------&quot;);</span><br><span class="line">        /*</span><br><span class="line">        方法二  键值对</span><br><span class="line">         */</span><br><span class="line">        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map1.entrySet();</span><br><span class="line">        for (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            Integer value = entry.getValue();</span><br><span class="line">            System.out.println(key+&quot;----&gt;&quot;+value);//遍历键值对</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;--------------&quot;);</span><br><span class="line">        /*</span><br><span class="line">        方法三：Lambda表达式</span><br><span class="line">         */</span><br><span class="line">        map1.forEach(new BiConsumer&lt;String, Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(String s, Integer integer) &#123;</span><br><span class="line">                System.out.println(s+&quot;----&gt;&quot;+integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="集合嵌套"><a href="#集合嵌套" class="headerlink" title="集合嵌套"></a>集合嵌套</h4><p>举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">需求</span><br><span class="line"> 要求在程序中记住如下省份和其对应的城市信息，记录成功后，要求可以查询出湖北省的城市信息。</span><br><span class="line">江苏省 = 南京市，扬州市，苏州市，无锡市，常州市</span><br><span class="line">湖北省 = 武汉市，孝感市，十堰市，宜昌市，鄂州市</span><br><span class="line">河北省 = 石家庄市，唐山市，邢台市，保定市，张家口</span><br><span class="line">市</span><br><span class="line">分析</span><br><span class="line"> 定义一个Map集合，键用表示省份名称，值表示城市名称，注意：城市会有多个。</span><br><span class="line"> 根据“湖北省”这个键获取对应的值展示即可。</span><br><span class="line"> */</span><br><span class="line">public class MapTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /*一般集合的遍历</span><br><span class="line">        Map&lt;String,String&gt;map=new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;江苏省&quot;,&quot;南京市 &quot;);</span><br><span class="line">        map.put(&quot;湖北省&quot;,&quot;武汉市 &quot;);</span><br><span class="line">        map.put(&quot;河北省&quot;,&quot;石家庄市 &quot;);</span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        entries.forEach(new Consumer&lt;Map.Entry&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Map.Entry&lt;String, String&gt; stringStringEntry) &#123;</span><br><span class="line">                System.out.println(stringStringEntry.getKey()+&quot;=&quot;+stringStringEntry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">         */</span><br><span class="line">        /*</span><br><span class="line">        集合的嵌套</span><br><span class="line">         */</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt;map=new HashMap&lt;&gt;();</span><br><span class="line">        //List&lt;String&gt;list=new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt;city1=new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt;city2=new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt;city3=new ArrayList&lt;&gt;();</span><br><span class="line">        //city1.addAll(list);</span><br><span class="line">        Collections.addAll(city1,&quot;南京市&quot;,&quot;扬州市&quot;,&quot;苏州市&quot;,&quot;无锡市&quot;,&quot;常州市&quot;);</span><br><span class="line">        Collections.addAll(city2,&quot;武汉市&quot;,&quot;孝感市&quot;,&quot;十堰市&quot;,&quot;宜昌市&quot;,&quot;鄂州市&quot;);</span><br><span class="line">        Collections.addAll(city3,&quot;石家庄市&quot;,&quot;唐山市&quot;,&quot;邢台市&quot;,&quot;保定市&quot;,&quot;张家口&quot;);</span><br><span class="line">        map.put(&quot;江苏省&quot;,city1);</span><br><span class="line">        map.put(&quot;湖北省&quot;,city2);</span><br><span class="line">        map.put(&quot;河北省&quot;,city3);</span><br><span class="line">        map.forEach(new BiConsumer&lt;String, List&lt;String&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(String s, List&lt;String&gt; strings) &#123;</span><br><span class="line">/*</span><br><span class="line">法一</span><br><span class="line"> */</span><br><span class="line">                System.out.print(s+&quot;=&quot;);</span><br><span class="line">                int i=0;</span><br><span class="line">                for (String string : strings) &#123;</span><br><span class="line">                    System.out.print(string);</span><br><span class="line">                    if(i&lt;strings.size()-1) &#123;</span><br><span class="line">                        System.out.print(&quot;, &quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">法二</span><br><span class="line"> */</span><br><span class="line">                System.out.print(s+&quot;=&quot;);</span><br><span class="line">                Iterator&lt;String&gt; iterator = strings.iterator();</span><br><span class="line">                while(iterator.hasNext())&#123;</span><br><span class="line">                    System.out.print(iterator.next());</span><br><span class="line">                    if(iterator.hasNext())&#123;</span><br><span class="line">                        System.out.print(&quot;,&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h4><p>什么是Stream？<br> 也叫Stream流，是Jdk8开始新增的一套API (java.util.stream.*)，可以用于操作集合或者数<br>组的数据。<br> 优势： Stream流大量的结合了Lambda的语法风格来编程，提供了一种更加强大，更加简单的方式<br>操作集合或者数组中的数据，代码更简洁，可读性更好。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*引入</span><br><span class="line">/*</span><br><span class="line">把集合中所有以“张”开头，且是3个字的元素存储到一个新的集合。</span><br><span class="line"> */</span><br><span class="line">public class StreamTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line">//        list.add(&quot;张无忌&quot;);</span><br><span class="line">//        list.add(&quot;周芷若&quot;);</span><br><span class="line">//        list.add(&quot;赵敏&quot;);</span><br><span class="line">//        list.add(&quot;张强&quot;);</span><br><span class="line">//        list.add(&quot;张三丰&quot;);</span><br><span class="line">        Collections.addAll(list,&quot;张无忌&quot;,&quot;周芷若&quot;,&quot;赵敏&quot;,&quot;张强&quot;,&quot;张三丰&quot;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        for (String s : list) &#123;</span><br><span class="line">            if(s.startsWith(&quot;张&quot;)&amp;&amp;s.length()==3)&#123;</span><br><span class="line">                list2.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //System.out.println(list2);</span><br><span class="line">        </span><br><span class="line">        //法二  用stream流来处理</span><br><span class="line">        //List&lt;String&gt; z = list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;) &amp;&amp; s.length() == 3).collect(Collectors.toList());</span><br><span class="line">        //也可链式编程</span><br><span class="line">        List&lt;String&gt; z = list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;) ).filter(a-&gt;a.length()==3).collect(Collectors.toList());</span><br><span class="line">        System.out.println(z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.imagehub.cc/images/2025/02/03/32d8232d1292444783fc752becdbfb29.png" alt="Snipaste 2025 02 03 21 17 24"></p>
<h5 id="获取Stream流"><a href="#获取Stream流" class="headerlink" title="获取Stream流"></a>获取Stream流</h5><p><img src="https://s1.imagehub.cc/images/2025/02/03/6ffddf6027b01506c139bcdddbfd13d1.png" alt="Snipaste 2025 02 03 22 11 19"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class StreamTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    // 1、如何获取List集合的Stream流？</span><br><span class="line">    List&lt;String&gt; names = new ArrayList&lt;&gt;();</span><br><span class="line">    Collections.addAll(names, &quot;张三丰&quot;,&quot;张无忌&quot;,&quot;周芷若&quot;,&quot;赵敏&quot;,&quot;张强&quot;);</span><br><span class="line">    Stream&lt;String&gt; stream = names.stream();</span><br><span class="line">    // 2、如何获取Set集合的Stream流？</span><br><span class="line">    Set&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">    Collections.addAll(set, &quot;刘德华&quot;,&quot;张曼玉&quot;,&quot;蜘蛛精&quot;,&quot;马德&quot;,&quot;德玛西亚&quot;);</span><br><span class="line">    Stream&lt;String&gt; stream1 = set.stream();</span><br><span class="line">    stream1.filter(s -&gt; s.contains(&quot;德&quot;)).forEach(s -&gt; System.out.println(s));</span><br><span class="line">    // 3、如何获取Map集合的Stream流？</span><br><span class="line">    Map&lt;String, Double&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;古力娜扎&quot;, 172.3);</span><br><span class="line">    map.put(&quot;迪丽热巴&quot;, 168.3);</span><br><span class="line">    map.put(&quot;马尔扎哈&quot;, 166.3);</span><br><span class="line">    map.put(&quot;卡尔扎巴&quot;, 168.3);</span><br><span class="line">    Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">    Stream&lt;String&gt; ks = keys.stream();</span><br><span class="line"></span><br><span class="line">    Collection&lt;Double&gt; values = map.values();</span><br><span class="line">    Stream&lt;Double&gt; vs = values.stream();</span><br><span class="line"></span><br><span class="line">    Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = map.entrySet();//键值对</span><br><span class="line">    Stream&lt;Map.Entry&lt;String, Double&gt;&gt; kvs = entries.stream();//对键值对使用Stream流后遍历</span><br><span class="line">    kvs.filter(e -&gt; e.getKey().contains(&quot;巴&quot;))</span><br><span class="line">            .forEach(e -&gt; System.out.println(e.getKey()+ &quot;--&gt;&quot; + e.getValue()));</span><br><span class="line">    // 4、如何获取数组的Stream流？</span><br><span class="line">    String[] names2 = &#123;&quot;张翠山&quot;, &quot;东方不败&quot;, &quot;唐大山&quot;, &quot;独孤求败&quot;&#125;;</span><br><span class="line">    Stream&lt;String&gt; s1 = Arrays.stream(names2);</span><br><span class="line">    Stream&lt;String&gt; s2 = Stream.of(names2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Stream提供的常用中间方法"><a href="#Stream提供的常用中间方法" class="headerlink" title="Stream提供的常用中间方法"></a>Stream提供的常用中间方法</h5><p><img src="https://s1.imagehub.cc/images/2025/02/03/7ea2c1769de561d6a08a1901d96c170a.png" alt="Snipaste 2025 02 03 23 27 03"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Objects;</span><br><span class="line">public class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private double height;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line">        if (o == null || getClass() != o.getClass()) return false;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        return age == student.age &amp;&amp; Double.compare(student.height, height) == 0 &amp;&amp; Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return Objects.hash(name, age, height);</span><br><span class="line">    &#125;</span><br><span class="line">    public Student() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public Student(String name, int age, double height) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public double getHeight() &#123;</span><br><span class="line">        return height;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setHeight(double height) &#123;</span><br><span class="line">        this.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &quot;, height=&quot; + height +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class StreamTest3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Double&gt; scores = new ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(scores, 88.5, 100.0, 60.0, 99.0, 9.5, 99.6, 25.0);</span><br><span class="line">        List&lt;Student&gt; students = new ArrayList&lt;&gt;();</span><br><span class="line">        Student s1 = new Student(&quot;蜘蛛精&quot;, 26, 172.5);</span><br><span class="line">        Student s2 = new Student(&quot;蜘蛛精&quot;, 26, 172.5);</span><br><span class="line">        Student s3 = new Student(&quot;紫霞&quot;, 23, 167.6);</span><br><span class="line">        Student s4 = new Student(&quot;白晶晶&quot;, 25, 169.0);</span><br><span class="line">        Student s5 = new Student(&quot;牛魔王&quot;, 35, 183.3);</span><br><span class="line">        Student s6 = new Student(&quot;牛夫人&quot;, 34, 168.5);</span><br><span class="line">        Collections.addAll(students, s1, s2, s3, s4, s5, s6);</span><br><span class="line">        // 需求1：找出成绩大于等于60分的数据，并升序后，再输出。</span><br><span class="line">        scores.stream().filter(s -&gt; s &gt;= 60).sorted().forEach(s -&gt; System.out.println(s));</span><br><span class="line">        System.out.println(&quot;----------------------------------------------------------------&quot;);</span><br><span class="line">        // 需求2：找出年龄大于等于23,且年龄小于等于30岁的学生，并按照年龄降序输出.</span><br><span class="line">        students.stream().filter(s -&gt; s.getAge() &gt;= 23 &amp;&amp; s.getAge() &lt;= 30)</span><br><span class="line">                .sorted((o1, o2) -&gt; o2.getAge() - o1.getAge())</span><br><span class="line">                .forEach(s -&gt; System.out.println(s));</span><br><span class="line">        System.out.println(&quot;----------------------------------------------------------------&quot;);</span><br><span class="line">        // 需求3：取出身高最高的前3名学生，并输出。</span><br><span class="line">        students.stream().sorted((o1, o2) -&gt; Double.compare(o2.getHeight(), o1.getHeight()))</span><br><span class="line">                .limit(3).forEach(System.out::println);</span><br><span class="line">        System.out.println(&quot;----------------------------------------------------------------&quot;);</span><br><span class="line">        // 需求4：取出身高倒数的2名学生，并输出。   s1 s2 s3 s4 s5 s6</span><br><span class="line">        students.stream().sorted((o1, o2) -&gt; Double.compare(o2.getHeight(), o1.getHeight()))</span><br><span class="line">                .skip(students.size() - 2).forEach(System.out::println);//也可直接升序比较然后取前几个，此处介绍skip方法</span><br><span class="line">        System.out.println(&quot;----------------------------------------------------------------&quot;);</span><br><span class="line">        // 需求5：找出身高超过168的学生叫什么名字，要求去除重复的名字，再输出。</span><br><span class="line">        //students.stream().filter(s -&gt; s.getHeight() &gt; 168).map(s-&gt;s.getName()).distinct().forEach(System.out::println);</span><br><span class="line">        //简化后:</span><br><span class="line">        students.stream().filter(s -&gt; s.getHeight() &gt; 168).map(Student::getName).distinct().forEach(System.out::println);</span><br><span class="line">        // distinct去重复，自定义类型的对象（若希望内容一样就认为重复，需要在自定义类中重写hashCode,equals，若未重写，认为地址不同就不算重复）</span><br><span class="line">        students.stream().filter(s -&gt; s.getHeight() &gt; 168).distinct().forEach(System.out::println);</span><br><span class="line">        System.out.println(&quot;----------------------------------------------------------------&quot;);</span><br><span class="line">        //需求6:合并两个流</span><br><span class="line">        Stream&lt;String&gt; st1 = Stream.of(&quot;张三&quot;, &quot;李四&quot;);</span><br><span class="line">        Stream&lt;String&gt; st2 = Stream.of(&quot;张三2&quot;, &quot;李四2&quot;, &quot;王五&quot;);</span><br><span class="line">        Stream&lt;String&gt; allSt = Stream.concat(st1, st2);</span><br><span class="line">        allSt.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>面试常见问题：为什么重写了equals()还要重写hashcode():</strong><br>当我们对比两个对象是否相等时，我们就可以先使用 hashCode 进行比较，如果比较的结果是 true，那么就可以使用 equals 再次确认两个对象是否相等，<br>如果比较的结果是 true，那么这两个对象就是相等的，否则其他情况就认为两个对象不相等。<br>这样就大大的提升了对象比较的效率，这也是为什么 Java 设计使用 hashCode 和 equals 协同的方式，来确认两个对象是否相等的原因。​<br>那为什么不直接使用 hashCode 就确定两个对象是否相等呢？​<br>这是因为不同对象的 hashCode 可能相同；但 hashCode 不同的对象一定不相等，所以使用 hashCode 可以起到快速初次判断对象是否相等的作用。<br>接下来回到主题，重写 equals 为什么一定要重写 hashCode？​<br>如果只重写了 equals 方法，那么默认情况下，Set 进行去重操作时，会先判断两个对象的 hashCode 是否相同，此时因为没有重写 hashCode 方法，所以会直接执行 Object 中的 hashCode 方法，而 Object 中的 hashCode 方法对比的是两个不同引用地址的对象，所以结果是 false，那么 equals 方法就不用执行了，直接返回的结果就是 false：两个对象不是相等的，于是就在 Set 集合中插入了两个相同的对象。​<br>但是，如果在重写 equals 方法时，也重写了 hashCode 方法，那么在执行判断时会去执行重写的 hashCode 方法，此时对比的是两个对象的所有属性的 hashCode 是否相同，于是调用 hashCode 返回的结果就是 true，再去调用 equals 方法，发现两个对象确实是相等的，于是就返回 true 了，因此 Set 集合就不会存储两个一模一样的数据了，于是整个程序的执行就正常了。</p>
<h5 id="Stream提供的常用终结方法"><a href="#Stream提供的常用终结方法" class="headerlink" title="Stream提供的常用终结方法"></a>Stream提供的常用终结方法</h5><p><img src="https://s1.imagehub.cc/images/2025/02/03/ba638df22d1722b5178bbc176a2b5cde.png" alt="Snipaste 2025 02 03 23 46 37"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class StreamTest4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Student&gt; students = new ArrayList&lt;&gt;();</span><br><span class="line">        Student s1 = new Student(&quot;蜘蛛精&quot;, 26, 172.5);</span><br><span class="line">        Student s2 = new Student(&quot;蜘蛛精&quot;, 26, 172.5);</span><br><span class="line">        Student s3 = new Student(&quot;紫霞&quot;, 23, 167.6);</span><br><span class="line">        Student s4 = new Student(&quot;白晶晶&quot;, 25, 169.0);</span><br><span class="line">        Student s5 = new Student(&quot;牛魔王&quot;, 35, 183.3);</span><br><span class="line">        Student s6 = new Student(&quot;牛夫人&quot;, 34, 168.5);</span><br><span class="line">        Collections.addAll(students, s1, s2, s3, s4, s5, s6);</span><br><span class="line">        // 需求1：请计算出身高超过168的学生有几人。</span><br><span class="line">        long size = students.stream().filter(s -&gt; s.getHeight() &gt; 168).count();</span><br><span class="line">        System.out.println(size);</span><br><span class="line">        // 需求2：请找出身高最高的学生对象，并输出。</span><br><span class="line">        //Optional&lt;Student&gt; max = students.stream().max((o1, o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight()));</span><br><span class="line">        Student s = students.stream().max((o1, o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight())).get();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        // 需求3：请找出身高最矮的学生对象，并输出。</span><br><span class="line">        Student ss = students.stream().min((o1, o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight())).get();</span><br><span class="line">        System.out.println(ss);</span><br><span class="line">        // 需求4：请找出身高超过170的学生对象，并放到一个新集合中去返回。</span><br><span class="line">        // 流只能收集一次。stream has already been operated upon or closed</span><br><span class="line">        //	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229)以下注释掉的是错误写法</span><br><span class="line">//        Stream&lt;Student&gt; studentStream = students.stream().filter(a -&gt; a.getHeight() &gt; 170);</span><br><span class="line">//        System.out.println(studentStream.collect(Collectors.toList()));</span><br><span class="line">//        System.out.println(studentStream.collect(Collectors.toSet()));</span><br><span class="line">        List&lt;Student&gt; students1 = students.stream().filter(a -&gt; a.getHeight() &gt; 170).collect(Collectors.toList());</span><br><span class="line">        Set&lt;Student&gt; students2 = students.stream().filter(a -&gt; a.getHeight() &gt; 170).collect(Collectors.toSet());</span><br><span class="line">        System.out.println(students1);</span><br><span class="line">        System.out.println(students2);</span><br><span class="line">        // 需求5：请找出身高超过170的学生对象，并把学生对象的名字和身高，存入到一个Map集合返回。</span><br><span class="line">        //转成Map集合要加distinct()去重！</span><br><span class="line">        Map&lt;String, Double&gt; map =</span><br><span class="line">                students.stream().filter(a -&gt; a.getHeight() &gt; 170)</span><br><span class="line">                        .distinct().collect(Collectors.toMap(a -&gt; a.getName(), a -&gt; a.getHeight()));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        // Object[] arr = students.stream().filter(a -&gt; a.getHeight() &gt; 170).toArray();</span><br><span class="line">        Student[] arr = students.stream().filter(a -&gt; a.getHeight() &gt; 170).toArray(len -&gt; new Student[len]);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前面没复习到的IO流以及IO框架"><a href="#前面没复习到的IO流以及IO框架" class="headerlink" title="前面没复习到的IO流以及IO框架"></a>前面没复习到的IO流以及IO框架</h3><p><a target="_blank" rel="noopener" href="https://imgse.com/i/pEFMGnO"><img src="https://s21.ax1x.com/2025/01/15/pEFMGnO.png" alt="pEFMGnO.png"></a><br>File是java.io.包下的类， File类的对象，用于代表当前操作系统的文件（可以是文件、或文件夹）<br>File类只能对文件本身进行操作，不能读写文件里面存储的数据<br>IO流用于读写数据的(可以读写文件，或网络中的数据)<br><a target="_blank" rel="noopener" href="https://imgse.com/i/pEAO7m8"><img src="https://s21.ax1x.com/2025/01/23/pEAO7m8.png" alt="pEAO7m8.png"></a><br>绝对路径：从盘符开始<br>File file1 &#x3D; new File(“D:\itheima\a.txt”);<br> 相对路径：不带盘符，默认直接到当前工程下的目录寻找文件。<br>File file3 &#x3D; new File(“模块名\a.txt”);<br>自己再复习看一下，暂时不记下来了后续遗忘的话再回来补</p>
<h3 id="前面没复习到的线程内容"><a href="#前面没复习到的线程内容" class="headerlink" title="前面没复习到的线程内容"></a>前面没复习到的线程内容</h3><h4 id="第三种创建线程的方法"><a href="#第三种创建线程的方法" class="headerlink" title="第三种创建线程的方法"></a>第三种创建线程的方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package ThreadLearning.ThreadLearn;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line">public class Way3 implements Callable&lt;String&gt; &#123;</span><br><span class="line">    private int n;</span><br><span class="line">    public Way3()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public Way3(int p)&#123;</span><br><span class="line">        this.n=p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for (int i = 0; i &lt;this.n ; i++) &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        //把sum转换为String类型</span><br><span class="line">        return (&quot;从0累加至&quot;+n+&quot;所得值为&quot;+Integer.valueOf(sum).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test2 &#123;</span><br><span class="line">    public static void main (String[] args)throws Exception &#123;</span><br><span class="line">        Callable&lt;String&gt;cal=new Way3(20);</span><br><span class="line">        FutureTask&lt;String&gt;ft=new FutureTask&lt;&gt;(cal);</span><br><span class="line">        new Thread(ft).start();</span><br><span class="line">        String rs=ft.get();//得到return的值</span><br><span class="line">        System.out.println(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>用户每发起一个请求，后台就需要创建一个新线程来处理，下次新任务来了肯定又要创建新线程处理的，而创建新线程的开销是很大的，并且请求过多时，肯定会产生大量的线程出来，这样会严重影响系统的性能。线程池就是一个可以复用线程的技术。<br> JDK 5.0起提供了代表线程池的接口：ExecutorService。<br> public interface ExecutorService extends Executor {</p>
<p> }<br>如何得到线程池对象?</p>
<h5 id="方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象。"><a href="#方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象。" class="headerlink" title="方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象。"></a>方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) </span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">参数一：corePoolSize : 指定线程池的核心线程的数量。 正式工：3</span><br><span class="line">参数二：maximumPoolSize：指定线程池的最大线程数量。最大员工数：5 临时工：2</span><br><span class="line">参数三：keepAliveTime ：指定临时线程的存活时间。临时工空闲多久被开除</span><br><span class="line">参数四：unit：指定临时线程存活的时间单位(秒、分、时、天） 枚举类</span><br><span class="line">参数五：workQueue：指定线程池的任务队列。客人排队的地方 接口，常见实现类：ArrayBlockingQueue , LinkedBlockingQueue</span><br><span class="line">参数六：threadFactory：指定线程池的线程工厂。负责招聘员工的</span><br><span class="line">要么自己写匿名内部类，要么用Executors.defaultThreadFactory()</span><br><span class="line">参数七：handler：指定线程池的任务拒绝策略（线程都在忙，任务队列也满了的时候，新任务来了该怎么处理）。 忙不过来咋办？</span><br><span class="line">1. new ThreadPoolExecutor.AbortPolicy()//实现类，public static class AbortPolicy implements RejectedExecutionHandler &#123;</span><br><span class="line">&#125; //丢弃任务并抛出RejectedExecutionException异常,是默认的策略</span><br><span class="line">2. new ThreadPoolExecutor.DiscardPolicy()// 丢弃任务，但是不抛出异常 这是不推荐的做法</span><br><span class="line">3. new ThreadPoolExecutor.DiscardOldestPolicy()// 抛弃队列中等待最久的任务 然后把当前任务加入队列中</span><br><span class="line">4. new ThreadPoolExecutor.CallerRunsPolicy()// 由主线程负责调用任务的run()方法从而绕过线程池直接执行</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>注意事项：<br>1、临时线程什么时候创建？<br>新任务提交时发现<strong>核心线程都在忙，任务队列也满了，并且还可以创建临时线程</strong>，此时才会创建临时线程。<br>2、什么时候会开始拒绝新任务？<br><strong>核心线程和临时线程都在忙，任务队列也满了，新的任务过来</strong>的时候才会开始拒绝任务。<br>常用方法:<br><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/Snipaste-2025-01-27-13-00-00.Cp7JCO"><img src="https://s1.imagehub.cc/images/2025/01/27/b9fe635192a2873d53c18031db64e013.png" alt="Snipaste 2025 01 27 13 00 00"></a></p>
<h6 id="处理Runnable任务"><a href="#处理Runnable任务" class="headerlink" title="处理Runnable任务"></a>处理Runnable任务</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)  &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService ex=new ThreadPoolExecutor(3,5,8, TimeUnit.SECONDS,</span><br><span class="line">                new ArrayBlockingQueue&lt;&gt;(4),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                new ThreadPoolExecutor.CallerRunsPolicy());//实现类</span><br><span class="line">        /*</span><br><span class="line">        * 线程池用Runnable方法</span><br><span class="line">         */</span><br><span class="line">        Runnable run=new MyRunnable();</span><br><span class="line">        //自动创建新线程</span><br><span class="line">        ex.execute(run);</span><br><span class="line">        ex.execute(run);</span><br><span class="line">        ex.execute(run);</span><br><span class="line">        //如果核心线程执行完了，这里就复用核心线程,但是个数到了4个后还是要创建临时线程 eg.输出仍是：pool-1-thread-1在执行;若没完，则只能进任务队列排队，不输出</span><br><span class="line">        ex.execute(run);</span><br><span class="line">        ex.execute(run);</span><br><span class="line">        ex.execute(run);</span><br><span class="line">        ex.execute(run);</span><br><span class="line">        //开始创造临时线程</span><br><span class="line">        ex.execute(run);</span><br><span class="line">        ex.execute(run);</span><br><span class="line">        ex.execute(run);//临时队列满了，默认的拒绝策略会报异常</span><br><span class="line">        //其他还有不报异常或者老板亲自对接</span><br><span class="line">        ex.shutdown();//等全部任务执行完毕后，再关闭线程池</span><br><span class="line">        //ex.shutdownNow();//立刻关闭线程池，停止正在执行的任务，并返回队列中未执行的任务</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="处理Callable任务"><a href="#处理Callable任务" class="headerlink" title="处理Callable任务"></a>处理Callable任务</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService ex=new ThreadPoolExecutor(3,5,8, TimeUnit.SECONDS,</span><br><span class="line">                new ArrayBlockingQueue&lt;&gt;(4),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                new ThreadPoolExecutor.AbortPolicy());//实现类</span><br><span class="line">        /*</span><br><span class="line">         * 线程池用Callable方法</span><br><span class="line">         */</span><br><span class="line">        Future&lt;String&gt; ft1=ex.submit(new Mycallable(5));</span><br><span class="line">        Future&lt;String&gt; ft2=ex.submit(new Mycallable(5));</span><br><span class="line">        Future&lt;String&gt; ft3=ex.submit(new Mycallable(5));</span><br><span class="line">        Future&lt;String&gt; ft4=ex.submit(new Mycallable(5));//FutureTask&lt;V&gt;相当于是Future&lt;V&gt;接口的实现类</span><br><span class="line">        System.out.println(ft1.get());</span><br><span class="line">        System.out.println(ft2.get());</span><br><span class="line">        System.out.println(ft3.get());</span><br><span class="line">        System.out.println(ft4.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象。"><a href="#方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象。" class="headerlink" title="方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象。"></a>方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象。</h5><p><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/Snipaste-2025-01-27-14-03-12.Cp7vjs"><img src="https://s1.imagehub.cc/images/2025/01/27/37db0bf2ea9fb4791f1d1e3389dcd992.png" alt="Snipaste 2025 01 27 14 03 12"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查看源码:</span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">        return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;//固定线程数</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        ExecutorService ex= Executors.newFixedThreadPool(33);</span><br><span class="line">        /*</span><br><span class="line">        ctrl+alt+delete:任务管理器中查看cpu核数</span><br><span class="line">        计算密集型的任务:核心线程数量=CPU的核数+1;</span><br><span class="line">        IO密集型的任务:核心线程数量=CPU的核数*2;</span><br><span class="line">         */</span><br><span class="line">        Future&lt;String&gt; ft1=ex.submit(new Mycallable(5));</span><br><span class="line">        Future&lt;String&gt; ft2=ex.submit(new Mycallable(5));</span><br><span class="line">        Future&lt;String&gt; ft3=ex.submit(new Mycallable(5));</span><br><span class="line">        Future&lt;String&gt; ft4=ex.submit(new Mycallable(5));</span><br><span class="line">        System.out.println(ft1.get());</span><br><span class="line">        System.out.println(ft2.get());</span><br><span class="line">        System.out.println(ft3.get());</span><br><span class="line">        System.out.println(ft4.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意事项:<br><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/Snipaste-2025-01-27-14-14-03.CpFiMU"><img src="https://s1.imagehub.cc/images/2025/01/27/fdc91b370e73cfabec9f1ccec8f629d9.png" alt="Snipaste 2025 01 27 14 14 03"></a></p>
<h3 id="特殊文件以及日志技术"><a href="#特殊文件以及日志技术" class="headerlink" title="特殊文件以及日志技术"></a>特殊文件以及日志技术</h3><p>特殊文件:<br>了解它们的特点、作用;学习使用程序读取它们里面的数据;学习使用程序把数据存储到这些文件里<br>日志技术：<br>把程序运行的信息，记录到文件中，方便程序员定位bug、并了解程序的执行情况等</p>
<h4 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h4><h5 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h5><p><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/Snipaste-2025-01-29-18-33-02.CpSDP4"><img src="https://s1.imagehub.cc/images/2025/01/29/20dd5c4d452373e80cfcebb875d92b7a.png" alt="Snipaste 2025 01 29 18 33 02"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//读</span><br><span class="line">public class PropertiesRead1 &#123;</span><br><span class="line">    /*</span><br><span class="line">    users.properties原内容如下</span><br><span class="line">    #改好了</span><br><span class="line">#Wed Jan 29 18:15:13 CST 2025</span><br><span class="line">admin=123456</span><br><span class="line">张无忌=minmin</span><br><span class="line">周芷若=ji</span><br><span class="line">赵敏=33</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Properties pre=new Properties();//空容器</span><br><span class="line">        System.out.println(pre);</span><br><span class="line">        pre.load(new FileReader(&quot;src/File/SpecialFile/users.properties&quot;));</span><br><span class="line">        System.out.println(pre);</span><br><span class="line">        //System.out.println(pre.getProperty(&quot;张无忌&quot;));</span><br><span class="line">        Set&lt;String&gt; strings = pre.stringPropertyNames();//获取全部键</span><br><span class="line">        for (String string : strings) &#123;</span><br><span class="line">            System.out.println(string+&quot;-&gt;&quot;+pre.getProperty(string));</span><br><span class="line">        &#125;//遍历全部键值对</span><br><span class="line">        System.out.println(&quot;----------&quot;);</span><br><span class="line">        Set&lt;Map.Entry&lt;Object, Object&gt;&gt; entries = pre.entrySet();</span><br><span class="line">        for (Map.Entry&lt;Object, Object&gt; entry : entries) &#123;</span><br><span class="line">            System.out.println(entry.getKey()+&quot;-&gt;&quot;+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;----------&quot;);</span><br><span class="line">        pre.forEach(new BiConsumer&lt;Object, Object&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Object o, Object o2) &#123;</span><br><span class="line">                System.out.println(o+&quot;-&gt;&quot;+o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//写</span><br><span class="line">public class PropertiesWrite2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Properties pro=new Properties();</span><br><span class="line">        pro.setProperty(&quot;几尔&quot;,&quot;aminos&quot;);</span><br><span class="line">        pro.store(new FileWriter(&quot;src/File/SpecialFile/users2.properties&quot;),&quot;go fuck yourself&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//改</span><br><span class="line">public class PropertiesExchange1 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Properties prop=new Properties();</span><br><span class="line">        prop.load(new FileReader(&quot;src/File/SpecialFile/users.properties&quot;));</span><br><span class="line">        if (prop.containsKey(&quot;赵敏&quot;)) &#123;//不用遍历，直接用containsKey方法</span><br><span class="line">            prop.setProperty(&quot;赵敏&quot;,&quot;33&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        prop.store(new FileWriter(&quot;src/File/SpecialFile/users.properties&quot;),&quot;改好了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="XML文件"><a href="#XML文件" class="headerlink" title="XML文件"></a>XML文件</h5><p>XML的全称为（EXtensible Markup Language），是一种可扩展的标记语言。<br>XML的作用和应用场景：<br>本质是一种数据格式，可以存储复杂的数据结构，和数据关系。<br>应用场景：经常用来做为系统的配置文件；或者作为一种特殊的数据结构，在网络中进行传输。</p>
<h6 id="如何写XML文件"><a href="#如何写XML文件" class="headerlink" title="如何写XML文件"></a>如何写XML文件</h6><p>XML的语法规则</p>
<ul>
<li>文件后缀一般是是xml，文档声明必须是第一行 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br></pre></td></tr></table></figure>
version：XML默认的版本号码、该属性是必须存在的<br>encoding：本XML文件的编码</li>
<li>必须存在一个根标签，有且只能有一个</li>
<li>XML文件中可以定义注释信息：&lt;!–- 注释内容 –&gt;</li>
<li>标签必须成对出现，有开始，有结束标签: <name></name></li>
<li>必须能够正确的嵌套</li>
<li>XML中书写”&lt;”、“&amp;”等，可能会出现冲突，导致报错，此时可以用如下特殊字符替代。<br>**&amp;lt**;      &lt; 小于<br>**&amp;gt**; &gt; 大于<br><strong>&amp;amp</strong>; &amp; 和号<br><strong>&amp;apos</strong>; ‘ 单引号<br><strong>&amp;quot</strong>; “ 引号<br>或者XML中可以写一个叫CDATA的数据区: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;![CDATA[ …内容… ]]&gt;</span><br></pre></td></tr></table></figure>
，里面的内容可以随便写。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!-- 注释：抬头申明必须第一行--&gt;</span><br><span class="line">&lt;users&gt;</span><br><span class="line">    &lt;user id=&quot;1&quot;&gt;</span><br><span class="line">        &lt;name&gt;张无忌&lt;/name&gt;</span><br><span class="line">        &lt;sex&gt;male&lt;/sex&gt;</span><br><span class="line">        &lt;age&gt;17&lt;/age&gt;</span><br><span class="line">        &lt;![CDATA[超市里的马&gt;我是逆蝶</span><br><span class="line">        ]]&gt;</span><br><span class="line">    &lt;/user&gt;</span><br><span class="line">    &lt;people money=&quot;7&quot;&gt;</span><br><span class="line">        &lt;name&gt;玉面手雷王&lt;/name&gt;</span><br><span class="line">        &lt;iq&gt;250&lt;/iq&gt;</span><br><span class="line">    &lt;/people&gt;</span><br><span class="line">    &lt;user id=&quot;2&quot;&gt;</span><br><span class="line">        &lt;name&gt;傻瓜&lt;/name&gt;</span><br><span class="line">        &lt;sex&gt;male&lt;/sex&gt;</span><br><span class="line">        &lt;age&gt;19&lt;/age&gt;</span><br><span class="line">    &lt;/user&gt;</span><br><span class="line">&lt;/users&gt;</span><br></pre></td></tr></table></figure>
<h6 id="如何利用程序读取XML文件中的数据"><a href="#如何利用程序读取XML文件中的数据" class="headerlink" title="如何利用程序读取XML文件中的数据"></a>如何利用程序读取XML文件中的数据</h6><p>使用Dom4J解析出XML文件<br>分析：<br>① 下载Dom4j框架，官网下载。<br>② 在项目中创建一个文件夹：lib<br>③ 将dom4j-2.1.3.jar文件复制到 lib 文件夹<br>④ 在jar文件上点右键，选择 Add as Library -&gt; 点击OK<br>⑤ 在类中导包使用<br><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/Snipaste-2025-01-30-00-40-39.CodPw7"><img src="https://s1.imagehub.cc/images/2025/01/30/0119f1196d2bb75d55e17d85ec65e3e9.png" alt="Snipaste 2025 01 30 00 40 39"></a><br><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/Snipaste-2025-01-30-00-40-29.CodRsJ"><img src="https://s1.imagehub.cc/images/2025/01/30/11ddc7b76c11d7c592980b12fe0dcbbd.png" alt="Snipaste 2025 01 30 00 40 29"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws DocumentException &#123;</span><br><span class="line">        SAXReader saxReader=new SAXReader();</span><br><span class="line">        Document read = saxReader.read(&quot;src/File/SpecialFile/newFirst.xml&quot;);</span><br><span class="line">        Element root = read.getRootElement();//根元素</span><br><span class="line">        System.out.println(root.getName());//users</span><br><span class="line">        //List&lt;Element&gt; elements = root.elements();</span><br><span class="line">        List&lt;Element&gt; elements2 = root.elements(&quot;user&quot;);//指定拿的内容</span><br><span class="line">        for (Element element : elements2) &#123;</span><br><span class="line">            System.out.println(element.getName());</span><br><span class="line">        &#125;//获取全部名为参数的一级子元素</span><br><span class="line">        System.out.println(&quot;------&quot;);</span><br><span class="line">        //法一</span><br><span class="line">        Element people = root.element(&quot;people&quot;);//拿到当前元素下的某个子元素</span><br><span class="line">        System.out.println(people.elementText(&quot;name&quot;));//玉面手雷王//子元素.elementText(&quot;子元素属性名&quot;)</span><br><span class="line">        //法二 相当于再遍历一层</span><br><span class="line">        Element name = people.element(&quot;name&quot;);</span><br><span class="line">        System.out.println(name.getText());//玉面手雷王</span><br><span class="line">        System.out.println(&quot;--------&quot;);</span><br><span class="line">        Element user = root.element(&quot;user&quot;);//如果下面有很多子元素，默认获取第一个</span><br><span class="line">        System.out.println(user.elementText(&quot;name&quot;));//这里拿到的是张无忌</span><br><span class="line">        System.out.println(user.elementText(&quot;age&quot;));//这里拿到的是17</span><br><span class="line">        Attribute id = user.attribute(&quot;id&quot;);</span><br><span class="line">        System.out.println(id.getName());//id  //子标题属性名</span><br><span class="line">        System.out.println(id.getValue());//1  //子标题属性值</span><br><span class="line">        List&lt;Attribute&gt; attributes = user.attributes();</span><br><span class="line">        for (Attribute attribute : attributes) &#123;</span><br><span class="line">            System.out.println(attribute.getName()+&quot;=&quot;+attribute.getValue());</span><br><span class="line">        &#125;//类似键值对  id=1</span><br><span class="line">        System.out.println(&quot;-------&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="如何利用程序把数据写出到XML文件中"><a href="#如何利用程序把数据写出到XML文件中" class="headerlink" title="如何利用程序把数据写出到XML文件中"></a>如何利用程序把数据写出到XML文件中</h6><p>建议直接把程序里的数据拼接成XML格式，然后用IO流写出去，不建议用dom4j做</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)  &#123;</span><br><span class="line">        StringBuilder sb=new StringBuilder();</span><br><span class="line">        sb.append(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot; ?&gt;\r\n&quot;);</span><br><span class="line">        sb.append(&quot;&lt;user id=\&quot;1\&quot;&gt;&quot;);</span><br><span class="line">        sb.append(&quot;&lt;name&gt;&quot;).append(&quot;张无忌&quot;).append(&quot;&lt;/name&gt;\n&quot;);//支持链式编程</span><br><span class="line">        sb.append(&quot;&lt;sex&gt;&quot;).append(&quot;male&quot;).append(&quot;&lt;/sex&gt;\n&quot;);</span><br><span class="line">        sb.append(&quot;&lt;age&gt;&quot;).append(&quot;17&quot;).append(&quot;&lt;/age&gt;\n&quot;);</span><br><span class="line">        sb.append(&quot;&lt;/user&gt;\n&quot;);</span><br><span class="line">        try(BufferedWriter writer=new BufferedWriter(new FileWriter(&quot;src/File/SpecialFile/WriteOut.xml&quot;));)</span><br><span class="line">        &#123;</span><br><span class="line">            writer.write(sb.toString());</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="补充知识：约束XML文件的编写-了解"><a href="#补充知识：约束XML文件的编写-了解" class="headerlink" title="补充知识：约束XML文件的编写[了解]"></a>补充知识：约束XML文件的编写[了解]</h6><p>限制XML文件只能按照某种格式进行书写<br>约束文档:专门用来限制xml书写格式的文档，比如：限制标签、属性应该怎么写。<br>约束文档的分类:DTD文档，Schema文档<br><img src="https://s1.imagehub.cc/images/2025/02/01/942e666b0ba9aec54c7490aed5480cb4.png" alt="Snipaste 2025 02 01 23 48 17"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//导入dtd约束文档</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE 书架 SYSTEM &quot;data.dtd&quot;&gt;</span><br><span class="line">&lt;书架&gt;</span><br><span class="line">    &lt;书&gt;</span><br><span class="line">        &lt;书名&gt;从入门到删库&lt;/书名&gt;</span><br><span class="line">        &lt;作者&gt;小猫&lt;/作者&gt;</span><br><span class="line">        &lt;售价&gt;很便宜&lt;/售价&gt;</span><br><span class="line">    &lt;/书&gt;</span><br><span class="line">    &lt;书&gt;</span><br><span class="line">        &lt;书名&gt;从入门到删库&lt;/书名&gt;</span><br><span class="line">        &lt;作者&gt;小猫&lt;/作者&gt;</span><br><span class="line">        &lt;售价&gt;9.9&lt;/售价&gt;</span><br><span class="line">    &lt;/书&gt;</span><br><span class="line">    &lt;书&gt;</span><br><span class="line">        &lt;书名&gt;从入门到删库&lt;/书名&gt;</span><br><span class="line">        &lt;作者&gt;小猫&lt;/作者&gt;</span><br><span class="line">        &lt;售价&gt;9.9&lt;/售价&gt;</span><br><span class="line">    &lt;/书&gt;</span><br><span class="line">&lt;/书架&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//schema约束文档</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;schema xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot;</span><br><span class="line">        targetNamespace=&quot;http://www.itcast.cn&quot;  //类似于包名</span><br><span class="line">        elementFormDefault=&quot;qualified&quot; &gt;</span><br><span class="line">    &lt;!-- targetNamespace:申明约束文档的地址（命名空间）--&gt;</span><br><span class="line">    &lt;element name=&#x27;书架&#x27;&gt;</span><br><span class="line">        &lt;!-- 写子元素 --&gt;</span><br><span class="line">        &lt;complexType&gt;</span><br><span class="line">            &lt;!-- maxOccurs=&#x27;unbounded&#x27;: 书架下的子元素可以有任意多个！--&gt;</span><br><span class="line">            &lt;sequence maxOccurs=&#x27;unbounded&#x27;&gt;</span><br><span class="line">                &lt;element name=&#x27;书&#x27;&gt;</span><br><span class="line">                    &lt;!-- 写子元素 --&gt;</span><br><span class="line">                    &lt;complexType&gt;</span><br><span class="line">                        &lt;sequence&gt;</span><br><span class="line">                            &lt;element name=&#x27;书名&#x27; type=&#x27;string&#x27;/&gt;</span><br><span class="line">                            &lt;element name=&#x27;作者&#x27; type=&#x27;string&#x27;/&gt;</span><br><span class="line">                            &lt;element name=&#x27;售价&#x27; type=&#x27;double&#x27;/&gt;</span><br><span class="line">                        &lt;/sequence&gt;</span><br><span class="line">                    &lt;/complexType&gt;</span><br><span class="line">                &lt;/element&gt;</span><br><span class="line">            &lt;/sequence&gt;</span><br><span class="line">        &lt;/complexType&gt;</span><br><span class="line">    &lt;/element&gt;</span><br><span class="line">&lt;/schema&gt;</span><br><span class="line"></span><br><span class="line">//导入schema约束文档</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;书架 xmlns=&quot;http://www.itcast.cn&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.itcast.cn data.xsd&quot;&gt;</span><br><span class="line">    &lt;!-- xmlns=&quot;http://www.itcast.cn&quot;  基本位置</span><br><span class="line">         xsi:schemaLocation=&quot;http://www.itcast.cn books02.xsd&quot; 具体的位置 --&gt;</span><br><span class="line">   &lt;书&gt;</span><br><span class="line">       &lt;书名&gt;从入门到删除&lt;/书名&gt;</span><br><span class="line">       &lt;作者&gt;dlei&lt;/作者&gt;</span><br><span class="line">       &lt;售价&gt;9.9&lt;/售价&gt;</span><br><span class="line">   &lt;/书&gt;</span><br><span class="line">    &lt;书&gt;</span><br><span class="line">        &lt;书名&gt;从入门到删除&lt;/书名&gt;</span><br><span class="line">        &lt;作者&gt;dlei&lt;/作者&gt;</span><br><span class="line">        &lt;售价&gt;0.9&lt;/售价&gt;</span><br><span class="line">    &lt;/书&gt;</span><br><span class="line">&lt;/书架&gt;</span><br></pre></td></tr></table></figure>
<h4 id="日志技术"><a href="#日志技术" class="headerlink" title="日志技术"></a>日志技术</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Scanner r=new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入r&quot;);</span><br><span class="line">        String number=r.next();</span><br><span class="line">        try &#123;</span><br><span class="line">            int result=Integer.valueOf(number);</span><br><span class="line">            //int result=Integer.parseInt(number);</span><br><span class="line">            System.out.println(&quot;整数值为&quot;+result);</span><br><span class="line">        &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;输入有误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    输出语句的弊端</span><br><span class="line"> 日志会展示在控制台</span><br><span class="line"> 不能更方便的将日志记录到其他的位置（文件，数据库）</span><br><span class="line"> 想取消日志，需要修改源代码才可以完成</span><br><span class="line">     */</span><br></pre></td></tr></table></figure>
<p>什么是日志？<br> 用来记录程序运行过程中的信息，并可以进行永久存储。<br>日志技术<br> 可以将系统执行的信息，方便的记录到指定的位置（控制台、文件中、数据库中）。<br> 可以随时以开关的形式控制日志的启停，无需侵入到源代码中去进行修改。<br> 多线程性能较好<br><img src="https://s1.imagehub.cc/images/2025/02/02/20956ce635733b17702e55a84620cca6.png" alt="Snipaste 2025 02 02 23 11 17"><br> 使用Logback日志框架记录日志的具体步骤是?<br>①：在项目下新建文件夹lib，导入Logback的相关jar包到该文件夹下，并添加到项目库中<br>去。<br>②：必须将Logback的核心配置文件logback.xml直接拷贝到<strong>src目录下</strong>。<br>③：在代码中获取日志的对象<br>④：调用日志对象的方法记录日志信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static final Logger LOGGER = LoggerFactory.getLogger(“类名&quot;);</span><br><span class="line">LOGGER.debug(&quot;参数a的值为：&quot;+a);</span><br><span class="line">LOGGER.info(&quot;chu法执行成功&quot;);</span><br><span class="line">LOGGER.error(&quot;chu法执行失败&quot;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        CONSOLE ：表示当前的日志信息是可以输出到控制台的。</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;!--输出流对象 默认 System.out 改为 System.err--&gt;</span><br><span class="line">        &lt;target&gt;System.out&lt;/target&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度</span><br><span class="line">                %msg：日志消息，%n是换行符--&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level]  %c [%thread] : %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- File是输出的方向通向文件的 --&gt;</span><br><span class="line">    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">            &lt;charset&gt;utf-8&lt;/charset&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">        &lt;!--日志输出路径--&gt;</span><br><span class="line">        &lt;file&gt;D:/log/itheima-data.log&lt;/file&gt;</span><br><span class="line">        &lt;!--指定日志文件拆分和压缩规则--&gt;</span><br><span class="line">        &lt;rollingPolicy</span><br><span class="line">                class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;!--通过指定压缩文件名称，来确定分割文件方式--&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;D:/log/itheima-data-%i-%d&#123;yyyy-MM-dd&#125;-.log.gz&lt;/fileNamePattern&gt;</span><br><span class="line">            &lt;!--文件拆分大小--&gt;</span><br><span class="line">            &lt;maxFileSize&gt;1MB&lt;/maxFileSize&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">        1、控制日志的输出情况：如，开启日志，取消日志</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;root level=&quot;debug&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;FILE&quot; /&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://s1.imagehub.cc/images/2025/02/03/506d0e74b5a3609b0a3c741ebb82d606.png" alt="Snipaste 2025 02 03 00 02 01"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">WZH</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/01/19/JavaSEReview3/">http://example.com/2024/01/19/JavaSEReview3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaSE/">JavaSE</a></div><div class="post-share"><div class="social-share" data-image="https://s21.ax1x.com/2024/12/21/pAO7nqH.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related  no-desc" href="/2024/12/19/firstArtical/" title="firstArtical"><img class="cover" src="https://s21.ax1x.com/2024/12/20/pAO4b9S.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">firstArtical</div></div></div></a><a class="pagination-related" href="/2024/01/16/QiMoJava2/" title="Java复习Day2"><img class="cover" src="https://s21.ax1x.com/2024/12/20/pAO4gpD.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Java复习Day2</div></div><div class="info-2"><div class="info-item-1"> Java复习Day2异常  Exception分类：Runtime Exception,其他异常  1  try-catch-finally  try(){    …  }catch(Exception e){    e.printStackTrace();  }finally{   }  2 throws  一层一层往外抛出，最外面的函数用try-catch围住  注意：放在参数后面 自定义异常  A(){    B();  }  B(){    代码段  }  1运行时异常  class AgeIsIllegal extends RuntimeException{    public AgeIsIllegal(String message){        super(message);    }  }  函数内部代码段throw new AgeIsIllegal(….)，A函数的B部分再用try-catch围住   2异常  public class NameNullException extends Exception{    public...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/01/16/QimoJava/" title="Java复习Day1"><img class="cover" src="https://s21.ax1x.com/2024/12/20/pAO4MOs.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-16</div><div class="info-item-2">Java复习Day1</div></div><div class="info-2"><div class="info-item-1"> Java复习Day1单例设计模式一、构造超级英雄类SuperHero，该类有String型常量属性name，其值固定为“谭雅”、“伊万”。要求：a. 在程序运行期间，至多只能造出一个对象，要么是谭雅，要么是伊万。b. 如何实现：在程序运行期间，至多只能造出两个对象，其中一个是谭雅，另一个是伊万。a 12345678910111213141516171819202122232425262728293031package SchoolJob.ExampleOnly1.OneExample;public class Superhero &#123;    private static  final String name1=&quot;谭雅&quot;;    private static  final String name2=&quot;伊万&quot;;    private Superhero()&#123;    &#125;//1.构造器私有化    public static Superhero a=new...</div></div></div></a><a class="pagination-related" href="/2024/01/16/QiMoJava2/" title="Java复习Day2"><img class="cover" src="https://s21.ax1x.com/2024/12/20/pAO4gpD.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-16</div><div class="info-item-2">Java复习Day2</div></div><div class="info-2"><div class="info-item-1"> Java复习Day2异常  Exception分类：Runtime Exception,其他异常  1  try-catch-finally  try(){    …  }catch(Exception e){    e.printStackTrace();  }finally{   }  2 throws  一层一层往外抛出，最外面的函数用try-catch围住  注意：放在参数后面 自定义异常  A(){    B();  }  B(){    代码段  }  1运行时异常  class AgeIsIllegal extends RuntimeException{    public AgeIsIllegal(String message){        super(message);    }  }  函数内部代码段throw new AgeIsIllegal(….)，A函数的B部分再用try-catch围住   2异常  public class NameNullException extends Exception{    public...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/joker.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">WZH</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/whazuppp"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/whazuppp" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:niceahaha@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%A4%8D%E4%B9%A0Day3"><span class="toc-number">1.</span> <span class="toc-text"> Java复习Day3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81API%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.1.</span> <span class="toc-text">常见API学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-toString"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1.toString()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-equals"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">2.equals()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-clone"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">3.clone()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Objects%E7%B1%BB"><span class="toc-number">1.1.2.</span> <span class="toc-text">Objects类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">包装类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String"><span class="toc-number">1.1.3.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#String-1"><span class="toc-number">1.1.3.0.1.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#StringBuilder"><span class="toc-number">1.1.3.0.2.</span> <span class="toc-text">StringBuilder</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#StringBuffer"><span class="toc-number">1.1.3.0.3.</span> <span class="toc-text">StringBuffer</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#StringJoiner"><span class="toc-number">1.1.3.0.4.</span> <span class="toc-text">StringJoiner</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Math"><span class="toc-number">1.1.4.</span> <span class="toc-text">Math</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#System"><span class="toc-number">1.1.5.</span> <span class="toc-text">System</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runtime"><span class="toc-number">1.1.6.</span> <span class="toc-text">Runtime</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BigDecimal"><span class="toc-number">1.1.7.</span> <span class="toc-text">BigDecimal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.1.8.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">成员内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">静态内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.1.8.3.</span> <span class="toc-text">匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arrays%E7%B1%BB"><span class="toc-number">1.1.9.</span> <span class="toc-text">Arrays类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.1.10.</span> <span class="toc-text">Lambda表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4"><span class="toc-number">1.2.</span> <span class="toc-text">时间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A7%E6%97%B6%E9%97%B4"><span class="toc-number">1.2.1.</span> <span class="toc-text">旧时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK8%E5%BC%80%E5%A7%8B%E7%9A%84%E6%96%B0%E6%97%B6%E9%97%B4"><span class="toc-number">1.2.2.</span> <span class="toc-text">JDK8开始的新时间</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%90%9E%E6%B8%85%E6%A5%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8JDK-8%E5%BC%80%E5%A7%8B%E6%96%B0%E5%A2%9E%E7%9A%84%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">搞清楚为什么要用JDK 8开始新增的时间类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Step1-%E4%BB%A3%E6%9B%BFCalendar1Date"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">Step1 代替Calendar1Date</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Step2-%E4%BB%A3%E6%9B%BFDate"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">Step2 代替Date</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Step3-%E4%BB%A3%E6%9B%BFSimpleDateFormat"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">Step3 代替SimpleDateFormat</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Step4-%E8%A1%A5%E5%85%85%EF%BC%9APeriod-Duration"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">Step4 补充：Period,Duration</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.3.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">1.4.1.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.2.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E3%80%81%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6%E3%80%81%E4%B8%8A%E4%B8%8B%E9%99%90"><span class="toc-number">1.4.3.</span> <span class="toc-text">泛型方法、泛型通配符、上下限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A%E6%93%A6%E9%99%A4%E9%97%AE%E9%A2%98%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.4.</span> <span class="toc-text">泛型的注意事项：擦除问题、基本数据类型问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">1.6.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Collection"><span class="toc-number">1.6.1.</span> <span class="toc-text">Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#List"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Set"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#HashSet%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8%EF%BC%88-%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%89"><span class="toc-number">1.6.1.2.1.</span> <span class="toc-text">HashSet底层原理:哈希表&#x3D;数组+链表（+红黑树）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#LinkedHashSet%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8-%E7%BA%A2%E9%BB%91%E6%A0%91-%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E5%A2%9E%E5%8A%A0%E4%BA%86%E5%8F%8C%E9%93%BE%E8%A1%A8%E6%9C%BA%E5%88%B6%E8%AE%B0%E4%BD%8F%E5%89%8D%E5%90%8E%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%9C%89%E5%BA%8F"><span class="toc-number">1.6.1.2.2.</span> <span class="toc-text">LinkedHashSet底层原理:数组+链表+红黑树(每个元素增加了双链表机制记住前后元素的位置，因此有序)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#TreeSet%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88%E6%8C%89%E7%85%A7%E5%A4%A7%E5%B0%8F%E9%BB%98%E8%AE%A4%E5%8D%87%E5%BA%8F%EF%BC%8C%E9%80%82%E7%94%A8%E4%BA%8E%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89"><span class="toc-number">1.6.1.2.3.</span> <span class="toc-text">TreeSet底层原理:红黑树（按照大小默认升序，适用于包装类和字符串）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">并发修改异常</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.6.1.5.</span> <span class="toc-text">Collections工具类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Collection%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-number">1.6.1.6.</span> <span class="toc-text">Collection业务场景分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map-%E9%94%AE%E5%80%BC%E5%AF%B9%E9%9B%86%E5%90%88"><span class="toc-number">1.6.2.</span> <span class="toc-text">Map(键值对集合)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Map%E5%BC%95%E5%85%A5"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">Map引入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Map%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">Map遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%B5%8C%E5%A5%97"><span class="toc-number">1.6.3.</span> <span class="toc-text">集合嵌套</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Stream%E6%B5%81"><span class="toc-number">1.6.4.</span> <span class="toc-text">Stream流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Stream%E6%B5%81"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">获取Stream流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Stream%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B8%B8%E7%94%A8%E4%B8%AD%E9%97%B4%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">Stream提供的常用中间方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Stream%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%88%E7%BB%93%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">Stream提供的常用终结方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E9%9D%A2%E6%B2%A1%E5%A4%8D%E4%B9%A0%E5%88%B0%E7%9A%84IO%E6%B5%81%E4%BB%A5%E5%8F%8AIO%E6%A1%86%E6%9E%B6"><span class="toc-number">1.7.</span> <span class="toc-text">前面没复习到的IO流以及IO框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E9%9D%A2%E6%B2%A1%E5%A4%8D%E4%B9%A0%E5%88%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AE%B9"><span class="toc-number">1.8.</span> <span class="toc-text">前面没复习到的线程内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%A7%8D%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.1.</span> <span class="toc-text">第三种创建线程的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.8.2.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8ExecutorService%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BBThreadPoolExecutor%E8%87%AA%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AF%B9%E8%B1%A1%E3%80%82"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">方式一：使用ExecutorService的实现类ThreadPoolExecutor自创建一个线程池对象。</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%84%E7%90%86Runnable%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.8.2.1.1.</span> <span class="toc-text">处理Runnable任务</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%84%E7%90%86Callable%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.8.2.1.2.</span> <span class="toc-text">处理Callable任务</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8Executors%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%89%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E7%89%B9%E7%82%B9%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AF%B9%E8%B1%A1%E3%80%82"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">方式二：使用Executors（线程池的工具类）调用方法返回不同特点的线程池对象。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E4%BB%A5%E5%8F%8A%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF"><span class="toc-number">1.9.</span> <span class="toc-text">特殊文件以及日志技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6"><span class="toc-number">1.9.1.</span> <span class="toc-text">特殊文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Properties"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">Properties</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#XML%E6%96%87%E4%BB%B6"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">XML文件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%86%99XML%E6%96%87%E4%BB%B6"><span class="toc-number">1.9.1.2.1.</span> <span class="toc-text">如何写XML文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AF%BB%E5%8F%96XML%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">1.9.1.2.2.</span> <span class="toc-text">如何利用程序读取XML文件中的数据</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%86%99%E5%87%BA%E5%88%B0XML%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-number">1.9.1.2.3.</span> <span class="toc-text">如何利用程序把数据写出到XML文件中</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%EF%BC%9A%E7%BA%A6%E6%9D%9FXML%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E5%86%99-%E4%BA%86%E8%A7%A3"><span class="toc-number">1.9.1.2.4.</span> <span class="toc-text">补充知识：约束XML文件的编写[了解]</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%8A%80%E6%9C%AF"><span class="toc-number">1.9.2.</span> <span class="toc-text">日志技术</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/21/hello-world/" title="Hello World"><img src="https://s21.ax1x.com/2024/12/20/pAO421e.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2024/12/21/hello-world/" title="Hello World">Hello World</a><time datetime="2024-12-21T07:47:48.750Z" title="Created 2024-12-21 15:47:48">2024-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/20/%E4%BA%BA%E8%84%89%E5%AE%9D/" title="人脉宝"><img src="https://s21.ax1x.com/2024/12/21/pAO7MdA.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="人脉宝"/></a><div class="content"><a class="title" href="/2024/12/20/%E4%BA%BA%E8%84%89%E5%AE%9D/" title="人脉宝">人脉宝</a><time datetime="2024-12-19T16:17:07.000Z" title="Created 2024-12-20 00:17:07">2024-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/19/firstArtical/" title="firstArtical"><img src="https://s21.ax1x.com/2024/12/20/pAO4b9S.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="firstArtical"/></a><div class="content"><a class="title" href="/2024/12/19/firstArtical/" title="firstArtical">firstArtical</a><time datetime="2024-12-19T06:23:47.000Z" title="Created 2024-12-19 14:23:47">2024-12-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/19/JavaSEReview3/" title="Java复习Day3"><img src="https://s21.ax1x.com/2024/12/21/pAO7nqH.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java复习Day3"/></a><div class="content"><a class="title" href="/2024/01/19/JavaSEReview3/" title="Java复习Day3">Java复习Day3</a><time datetime="2024-01-19T12:17:07.000Z" title="Created 2024-01-19 20:17:07">2024-01-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/16/QiMoJava2/" title="Java复习Day2"><img src="https://s21.ax1x.com/2024/12/20/pAO4gpD.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java复习Day2"/></a><div class="content"><a class="title" href="/2024/01/16/QiMoJava2/" title="Java复习Day2">Java复习Day2</a><time datetime="2024-01-16T12:17:07.000Z" title="Created 2024-01-16 20:17:07">2024-01-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By WZH</div><div class="footer_custom_text">Why do we fall<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://assets.akilar.top/image/cover1.webp);"> <a class="categoryBar-list-link" href="categories/JavaSE/">JavaSE</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">C/C++项目</span></li><li class="categoryBar-list-item" style="background:url(https://assets.akilar.top/image/cover2.webp);"> <a class="categoryBar-list-link" href="categories/C-C-项目/">C/C++项目</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">JavaSE</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/01/19/JavaSEReview3/" alt=""><img width="48" height="48" src="https://s21.ax1x.com/2024/12/21/pAO7nqH.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-19</span><a class="blog-slider__title" href="2024/01/19/JavaSEReview3/" alt="">Java复习Day3</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2024/01/19/JavaSEReview3/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/01/16/QiMoJava2/" alt=""><img width="48" height="48" src="https://s21.ax1x.com/2024/12/20/pAO4gpD.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-16</span><a class="blog-slider__title" href="2024/01/16/QiMoJava2/" alt="">Java复习Day2</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2024/01/16/QiMoJava2/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/01/16/QimoJava/" alt=""><img width="48" height="48" src="https://s21.ax1x.com/2024/12/20/pAO4MOs.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-16</span><a class="blog-slider__title" href="2024/01/16/QimoJava/" alt="">Java复习Day1</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2024/01/16/QimoJava/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/12/20/人脉宝/" alt=""><img width="48" height="48" src="https://s21.ax1x.com/2024/12/21/pAO7MdA.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-12-20</span><a class="blog-slider__title" href="2024/12/20/人脉宝/" alt="">人脉宝</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2024/12/20/人脉宝/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/12/19/firstArtical/" alt=""><img width="48" height="48" src="https://s21.ax1x.com/2024/12/20/pAO4b9S.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-12-19</span><a class="blog-slider__title" href="2024/12/19/firstArtical/" alt="">firstArtical</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2024/12/19/firstArtical/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/12/21/hello-world/" alt=""><img width="48" height="48" src="https://s21.ax1x.com/2024/12/20/pAO421e.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-12-21</span><a class="blog-slider__title" href="2024/12/21/hello-world/" alt="">Hello World</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2024/12/21/hello-world/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>